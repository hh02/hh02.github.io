<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 小象不小</title><link>https://hh02.github.io/post/</link><description>Recent content in Posts on 小象不小</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 25 Oct 2021 17:14:15 +0800</lastBuildDate><atom:link href="https://hh02.github.io/post/index.xml" rel="self" type="application/rss+xml"/><item><title>LeetCode 75. Sort Colors</title><link>https://hh02.github.io/p/leetcode-75.-sort-colors/</link><pubDate>Mon, 25 Oct 2021 17:14:15 +0800</pubDate><guid>https://hh02.github.io/p/leetcode-75.-sort-colors/</guid><description>题目 Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue. We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively. You must solve this problem without using the library&amp;rsquo;s sort function. Example 1: Input: nums =</description></item><item><title>LeetCode 74. Search a 2D Matrix</title><link>https://hh02.github.io/p/leetcode-74.-search-a-2d-matrix/</link><pubDate>Mon, 25 Oct 2021 17:00:43 +0800</pubDate><guid>https://hh02.github.io/p/leetcode-74.-search-a-2d-matrix/</guid><description>题目 Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. Example 1: 20211025170139 Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3 Output: true 思路 思路一：先对第</description></item><item><title>LeetCode 33. Search in Rotated Sorted Array</title><link>https://hh02.github.io/p/leetcode-33.-search-in-rotated-sorted-array/</link><pubDate>Mon, 25 Oct 2021 16:47:56 +0800</pubDate><guid>https://hh02.github.io/p/leetcode-33.-search-in-rotated-sorted-array/</guid><description>题目 There is an integer array nums sorted in ascending order (with distinct values). Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 &amp;lt;= k &amp;lt; nums.length) such that the resulting array is [nums[k], nums[k+1], &amp;hellip;, nums[n-1], nums[0], nums[1], &amp;hellip;, nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2]. Given the array nums after</description></item><item><title>LeetCode Weekly Contest 264</title><link>https://hh02.github.io/p/leetcode-weekly-contest-264/</link><pubDate>Mon, 25 Oct 2021 15:22:51 +0800</pubDate><guid>https://hh02.github.io/p/leetcode-weekly-contest-264/</guid><description>2048. Next Greater Numerically Balanced Number 题目 An integer x is numerically balanced if for every digit d in the number x, there are exactly d occurrences of that digit in x. Given an integer n, return the smallest numerically balanced number strictly greater than n. Example 1: Input: n = 1 Output: 22 Explanation: 22 is numerically balanced since: - The digit 2 occurs 2 times. It is</description></item><item><title>LeetCode 945. Minimum Increment to Make Array Unique</title><link>https://hh02.github.io/p/leetcode-945.-minimum-increment-to-make-array-unique/</link><pubDate>Mon, 25 Oct 2021 15:13:52 +0800</pubDate><guid>https://hh02.github.io/p/leetcode-945.-minimum-increment-to-make-array-unique/</guid><description>题目 You are given an integer array nums. In one move, you can pick an index i where 0 &amp;lt;= i &amp;lt; nums.length and increment nums[i] by 1. Return the minimum number of moves to make every value in nums unique. Example 1: Input: nums = [1,2,2] Output: 1 Explanation: After 1 move, the array could be [1, 2, 3]. 思路 遍历 nums 数组，遇</description></item><item><title>LeetCode 206. Reverse Linked List</title><link>https://hh02.github.io/p/leetcode-206.-reverse-linked-list/</link><pubDate>Sat, 23 Oct 2021 23:21:59 +0800</pubDate><guid>https://hh02.github.io/p/leetcode-206.-reverse-linked-list/</guid><description>题目 Given the head of a singly linked list, reverse the list, and return the reversed list. Example 1: 20211023233452 Input: head = [1,2,3,4,5] Output: [5,4,3,2,1] 思路 有迭代和递归两种写法。 代码 迭代 class Solution { public: ListNode* reverseList(ListNode* head) { if (head == nullptr) return nullptr; ListNode* p1 = nullptr; ListNode* p2 = head; ListNode* p3; while(p2) {</description></item><item><title>LeetCode 378. Kth Smallest Element in a Sorted Matrix</title><link>https://hh02.github.io/p/leetcode-378.-kth-smallest-element-in-a-sorted-matrix/</link><pubDate>Fri, 22 Oct 2021 23:03:34 +0800</pubDate><guid>https://hh02.github.io/p/leetcode-378.-kth-smallest-element-in-a-sorted-matrix/</guid><description>题目 Given an n x n matrix where each of the rows and columns are sorted in ascending order, return the kth smallest element in the matrix. Note that it is the kth smallest element in the sorted order, not the kth distinct element. 思路 二分查找。查找比 mid 小的有多少个。因为矩阵是有序</description></item><item><title>LeetCode刷题20211011</title><link>https://hh02.github.io/p/leetcode%E5%88%B7%E9%A2%9820211011/</link><pubDate>Mon, 11 Oct 2021 19:30:44 +0800</pubDate><guid>https://hh02.github.io/p/leetcode%E5%88%B7%E9%A2%9820211011/</guid><description>38.外观数列 class Solution { public: string countAndSay(int n) { if (n == 1) { return &amp;#34;1&amp;#34;; } string t1 = &amp;#34;1&amp;#34;; string t2 = &amp;#34;&amp;#34;; for (int i = 2; i &amp;lt;= n; i++) { int j = 0; int len = t1.size(); while (j &amp;lt; len) { int cnt = 1; while (j + 1 &amp;lt; len &amp;amp;&amp;amp; t1[j] == t1[j+1]) { j++;</description></item><item><title>LeetCode刷题2021 10 10</title><link>https://hh02.github.io/p/leetcode%E5%88%B7%E9%A2%982021-10-10/</link><pubDate>Sun, 10 Oct 2021 22:54:10 +0800</pubDate><guid>https://hh02.github.io/p/leetcode%E5%88%B7%E9%A2%982021-10-10/</guid><description>29 两数相除 要求不使用乘法、除法和 mod 运算符。 class Solution { public: int divide(int dividend, int divisor) { if (dividend == 0) return 0; if (divisor == 1) return dividend; if (divisor == -1) { if (dividend &amp;gt; INT_MIN) return -dividend; return INT_MAX; } long long a = dividend; long long b = divisor; int sign =</description></item><item><title>LeetCode刷题2021 10 8</title><link>https://hh02.github.io/p/leetcode%E5%88%B7%E9%A2%982021-10-8/</link><pubDate>Fri, 08 Oct 2021 23:21:36 +0800</pubDate><guid>https://hh02.github.io/p/leetcode%E5%88%B7%E9%A2%982021-10-8/</guid><description>题目 题目难度 提交次数 #14 最长公共前缀 简单 1 次 #13 罗马数字转整数 简单 3 次 #12 整数转罗马数字 中等 2 次 #11 盛最多水的容器 中等 1 次 #9 回文数 简单 1 次 #8 字符串转</description></item></channel></rss>