[{"content":"Chapter 01: business subdomains\u0026rsquo; boundaries and types.\nThis chapter continues the topic of business domain analysis but in a different dimension: depth. It focuses on what happens inside a subdomain: its business function and logic.\nBusiness Problems Business problems appear both at the business domain and subdomain levels.\nKnowledge Discovery To be effective, the software has to mimic the domain experts\u0026rsquo; way of thinking about the problem—their mental models.\nCommunication During the traditional software development lifecycle, the domain knowledge is \u0026ldquo;translated\u0026rdquo; into an engineer-friendly form known as an analysis model, which is a description of the system\u0026rsquo;s requirements rather than an understanding of the business domain behind it. While the intentions may be good, such mediation is hazardous to knowledge sharing. In any translation, information is lost;\n信息随着传递环节的增多，会变得不可信。\n减少信息的翻译，让 PM, RD 等所有参与者使用同一套语言。\nWhat Is a Ubiquitous Language Using a ubiquitous language is the cornerstone practice of domain-driven design. The idea is simple and straightforward: if parties need to communicate efficiently, instead of relying on translations, they have to speak the same language. （书同文）\nThe traditional software development lifecycle implies the following translations:\nDomain knowledge into an analysis model Analysis model into requirements Requirements into system design System design into source code Instead of continuously translating domain knowledge, domain-driven design calls for cultivating a single language for describe the business domain: the ubiquitous language.\nAll project-related stakeholders—software engineers, product owners, domain experts, UI/UX designers—should use the ubiquitous language when describing the business domain.\nLanguage of the Business The ubiquitous language is the language of the business. As such, it should consist of business domain—related terms only. No technical jargon!\nConsistency The ubiquitous language must be precise and consistent. It should eliminate the need for assumptions and should make the business domain\u0026rsquo;s logic explicit.\nAmbiguous terms The term policy has multiple meanings: it can mean a regulatory rule or an insurance contract. The exact meaning can be worked out in human-to-human interaction, depending on the context. Software, however doesn\u0026rsquo;t cope well with ambiguity, and it can be cumbersome and challenging to model the \u0026ldquo;policy\u0026rdquo; entity in code.\nUbiquitous language demands a single meaning for each term, so \u0026ldquo;policy\u0026rdquo; should be modeled explicitly using the two terms regulatory rule and insurance contract.\nSynonymous terms It is preferable to use each term explicitly in its specific context. Understanding the differences between the terms in use allows for building simpler and clearer models and implementations of the business domain\u0026rsquo;s entities.\nModel of the business Domain What Is a Model? A model is a simplified representation of a thing or phenomenon that intentionally emphasizes certain aspects while ignoring others. Abstraction with a specific use in mind. —Rebecca Wirfs-Brock\nEffective Modeling A useful is not a copy of the real world, instead a model is intended to solve a problem, and it should provide just enough information for that purpose.\nAll models are wrong, but some are useful.\nContinuous Effort Cultivation of a ubiquitous language is an ongoing process. It should be constantly validated and evolved.\nTools A wiki can be used as a glossary to capture and document the ubiquitous language. It\u0026rsquo;s important to make glossary maintenance a shared effort (not centralized).\nGlossaries work best for \u0026ldquo;nouns\u0026rdquo;: names of entities, processes, roles, and so on. Behavior is also important. The behavior is not a mere list of verbs associated with nouns, but the actual business logic, with its rules, assumptions, and invariants. Such concepts are much harder to document in a glossary.\nHence, glossaries are best used in tandem with other tools that are better suited to capture the behavior; for example, use cases or Gherkin tests.\nAutomated tests written in the Gherkin language are not only great tools for capturing the ubiquitous language but also act as an additional tool for bridging the gap between domain experts and software engineers.\nFinally, there are even static code analysis tools that can verify the usage of a ubiquitous language\u0026rsquo;s terms. A notable example for such a tool is NDepend.\nChallenges Finally, the question about the ubiquitous language that I an asked often at conferences is what language should we use if the company is not an English-speaking country. My advice is to at least use English nouns for naming the business domain\u0026rsquo;s entities. This will alleviate using the same terminology in code.\n","date":"2023-08-20T22:17:15+08:00","permalink":"https://hh02.github.io/p/learning-ddd-02-discovering-domain-knowledge/","title":"[Learning DDD] 02 Discovering Domain Knowledge"},{"content":"What Is a Business Domain? A business domain defines a company\u0026rsquo;s main area of activity. Generally speaking, it\u0026rsquo;s the service the company provides to its clients.\nFor example:\nFedEx provides courier delivery. Starbucks is best known for its coffee. Walmart is one of the most widely recognized retail establishments. What is a Subdomain? To achieve its business domain\u0026rsquo;s goals and targets, a company has to operate in multiple subdomains.\nA subdomain is a fine-grained area of business activity. All of a company\u0026rsquo;s subdomains form its business domain: the service it provides to its customers.\nFor example, Starbucks may be most recoginized for its coffee, but building a successful coffeehouse chain requires more than just knowing how to make great coffee. You also have to buy or rent real estate at effective locations, hire personnel, and manage finances, among other activities.\nTypes of Subdomains Core subdomains A core subdomain is what a company does differently from its competitors.\nA core subdomain that is simple to implement can only provide a short-lived competitive advantage. Therefore, core subdomains are naturally complex.\nGeneric subdomains Generic subdomains are business activities that all companies are performing in the same way.\nSupporting subdomains Supporting subdomains support the company\u0026rsquo;s business.\nComparing Subdomains Subdomain type Competitive Advantage Complexity Volatility Implementation Problem Core Yes High High In-house Interesting Generic No High Low Buy/adopt Solved Supporting No Low Low In-house/outsource Obvious Identifying Subdomain Boundaries Coarse-grained subdomains: A good starting point is the company\u0026rsquo;s departments and other organizational units.\nDistilling subdomains Analyzing the inner workings of a suspectedly generic subdomain to find the finer-grained subdomains.\nOn the other hand, we cannot drill down indefinitely, looking for insights at lower and lower levels of granularity. When should you stop?\nSubdomains as coherent use cases From a technical perspective, subdomains resemble sets of interrelated, coherent use cases. Such sets of use cases usually involve the same actor, the business entities, and they all manipulate a closely related set of data.\nWe can use the definition of \u0026ldquo;subdomains as a set of coherent use cases\u0026rdquo; as a guiding principle for when to stop looking for finer-grained subdomains. These are the most precise boundaries of the subdomains.\nFocus on the essentials When looking for subdomains, it\u0026rsquo;s important to identify business functions that are not related to software, acknowledge them as such, and focus on aspects of the business that are relevant to the software system you are working on.\nWho Are the Domain Experts? Domain experts are subject matter experts who know all the intricacies of the business that we are going to model and implement in code. In other words, domain experts are knowledge authorities in the software\u0026rsquo;s business domain.\n","date":"2023-08-20T17:22:21+08:00","permalink":"https://hh02.github.io/p/learning-ddd-01-analyzing-business-domains/","title":"[Learning DDD] 01 Analyzing Business Domains"},{"content":"题目 Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.\nImplement KthLargest class:\nKthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of integers nums. int add(int val) Appends the integer val to the stream and returns the element representing the kth largest element in the stream.\nExample 1:\nInput [\u0026#34;KthLargest\u0026#34;, \u0026#34;add\u0026#34;, \u0026#34;add\u0026#34;, \u0026#34;add\u0026#34;, \u0026#34;add\u0026#34;, \u0026#34;add\u0026#34;] [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]] Output [null, 4, 5, 5, 8, 8] Explanation KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]); kthLargest.add(3); // return 4 kthLargest.add(5); // return 5 kthLargest.add(10); // return 5 kthLargest.add(9); // return 8 kthLargest.add(4); // return 8 思路 本来的思路想用插入排序做的，这样的复杂度比较高。\n另一种做法是用优先队列，优先队列中只保留k个元素，因为优先队列是大根堆，所以要先将其转为小根堆，只有k个元素小根堆的堆顶就是第k大的值，每次add的时间复杂度只有 O(logn)。\n代码 class KthLargest { public: priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; q; int k; KthLargest(int k, vector\u0026lt;int\u0026gt;\u0026amp; nums) { this-\u0026gt;k = k; for (auto\u0026amp; x: nums) { add(x); } } int add(int val) { q.push(val); if (q.size() \u0026gt; k) { q.pop(); } return q.top(); } }; ","date":"2021-11-22T23:16:25+08:00","permalink":"https://hh02.github.io/p/leetcode-703.-kth-largest-element-in-a-stream/","title":"LeetCode 703. Kth Largest Element in a Stream"},{"content":"题目 You are given a doubly linked list, which contains nodes that have a next pointer, a previous pointer, and an additional child pointer. This child pointer may or may not point to a separate doubly linked list, also containing these special nodes. These child lists may have one or more children of their own, and so on, to produce a multilevel data structure as shown in the example below.\nGiven the head of the first level of the list, flatten the list so that all the nodes appear in a single-level, doubly linked list. Let curr be a node with a child list. The nodes in the child list should appear after curr and before curr.next in the flattened list.\nReturn the head of the flattened list. The nodes in the list must have all of their child pointers set to null.\nExample 1:\n20211122225308 Input: head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12] Output: [1,2,3,7,8,11,12,9,10,4,5,6] Explanation: The multilevel linked list in the input is shown. After flattening the multilevel linked list it becomes: 20211122225339 思路 这题没想出来，看了题解的代码也看了好久才看懂，不过看到评论里有说：前序遍历+重新串联，简单粗暴，不过用时有点长，其实这个可以看成二叉树。\n当我们遍历到某个节点 node 时，如果它的child成员不为空，那么我们需要将child只想的链表结构进行扁平化，并且插入node与node的下一个节点之间。\n因此，我们在遇到child成员不为空的节点时，就要先去处理child指向的链表结构，这就是一个深度优先搜索的过程。当我们完成了对child指向的链表结构的扁平化之后，就可以回溯到node节点。\n为了能够将扁平化的链表插入node与node的下一个节点之间，我们需要知道扁平化的链表的最后一个节点last，随后进行如下的散步操作：\n将node与node的下一个节点next断开； 将node与child相连； 将last与next相连。 这样一来，我们就可以将扁平化的链表成功地插入。\n代码 /* // Definition for a Node. class Node { public: int val; Node* prev; Node* next; Node* child; }; */ class Solution { public: Node* dfs(Node* node) { Node* cur = node; Node* last = nullptr; while (cur) { Node* next = cur-\u0026gt;next; if (cur-\u0026gt;child) { Node* child_last = dfs(cur-\u0026gt;child); next = cur-\u0026gt;next; cur-\u0026gt;next = cur-\u0026gt;child; cur-\u0026gt;child-\u0026gt;prev = cur; if (next) { child_last-\u0026gt;next = next; next-\u0026gt;prev = child_last; } cur-\u0026gt;child = nullptr; last = child_last; } else { last = cur; } cur = next; } return last; } Node* flatten(Node* head) { dfs(head); return head; } }; 令附先序遍历+重新串联：\nclass Solution { vector\u0026lt;Node*\u0026gt; v; public: void dfs(Node* head){ if(head==NULL) return; v.push_back(head); dfs(head-\u0026gt;child); dfs(head-\u0026gt;next); } Node* flatten(Node* head) { dfs(head); int n = v.size(); for(int i = 0;i\u0026lt;n;i++){ if(i+1\u0026lt;n) v[i]-\u0026gt;next = v[i+1]; if(i\u0026gt;0) v[i]-\u0026gt;prev = v[i-1]; v[i]-\u0026gt;child = NULL; } return head; } }; ","date":"2021-11-22T22:50:39+08:00","permalink":"https://hh02.github.io/p/leetcode-430.-flatten-a-multilevel-doubly-linked-list/","title":"LeetCode 430. Flatten a Multilevel Doubly Linked List"},{"content":"题目 Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.\nNote that the same word in the dictionary may be reused multiple times in the segmentation.\nExample 1:\nInput: s = \u0026#34;leetcode\u0026#34;, wordDict = [\u0026#34;leet\u0026#34;,\u0026#34;code\u0026#34;] Output: true Explanation: Return true because \u0026#34;leetcode\u0026#34; can be segmented as \u0026#34;leet code\u0026#34;. 思路 动态规划，dp[i] = dp[j] \u0026amp;\u0026amp; check(j+1, i);\n其中 check 用来检查某一个字串是否在dictSet中， dictSet 可以用stl库中的set（或者unordered_set)。\n代码 class Solution { public: bool wordBreak(string s, vector\u0026lt;string\u0026gt;\u0026amp; wordDict) { auto wordDictSet = unordered_set \u0026lt;string\u0026gt; (); for (auto word: wordDict) { wordDictSet.insert(word); } bool dp[s.size() + 1]; memset(dp, 0, sizeof(dp)); dp[0] = true; for (int i = 1; i \u0026lt;= s.size(); i++) { for (int j = 0; j \u0026lt; i; j++) { if (dp[j] \u0026amp;\u0026amp; wordDictSet.find(s.substr(j, i-j)) != wordDictSet.end()) { dp[i] = true; break; } } } return dp[s.size()]; } }; ","date":"2021-11-22T22:23:26+08:00","permalink":"https://hh02.github.io/p/leetcode-139.-word-break/","title":"LeetCode 139. Word Break"},{"content":"题目 Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\nNotice that the solution set must not contain duplicate triplets.\n思路 与 2sum 类似，先对数组进行排序，枚举前两个数，第三个数是单减的。注意不要枚举重复了。\n代码 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; threeSum(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); sort(nums.begin(), nums.end()); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; for (int i = 0; i \u0026lt; n; i++) { if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i-1]) continue; int k = n - 1; int target = -nums[i]; for (int j = i + 1; j \u0026lt; n; j++) { if (j \u0026gt; i + 1 \u0026amp;\u0026amp; nums[j] == nums[j-1]) continue; while (j \u0026lt; k \u0026amp;\u0026amp; nums[j] + nums[k] \u0026gt; target) k--; if (k == j) break; if (nums[j] + nums[k] == target) { ans.push_back({nums[i], nums[j], nums[k]}); } } } return ans; } }; ","date":"2021-11-15T23:56:08+08:00","permalink":"https://hh02.github.io/p/leetcode-15.-3sum/","title":"LeetCode 15. 3Sum"},{"content":"题目 There are n children standing in a line. Each child is assigned a rating value given in the integer array ratings.\nYou are giving candies to these children subjected to the following requirements:\nEach child must have at least one candy. Children with a higher rating get more candies than their neighbors. Return the minimum number of candies you need to have to distribute the candies to the children.\nExample 1:\nInput: ratings = [1,0,2] Output: 5 Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively. 思路 一开始的思路是首先最小值的糖果数是 1，因为没有比它更小的了，然后再去确定次小值。这样直接对原数组排序，从小往大去更新。这样做的时间复杂度是 nlogn。\n后来看了题解，有更优的做法。设第 i 个人的糖果个数为 cnt[i], 想了半天也没想明白……\n代码 class Solution { public: int candy(vector\u0026lt;int\u0026gt;\u0026amp; ratings) { int n = ratings.size(); int l[n+1], r[n+1]; for (int i = 0; i \u0026lt; n; i++) { l[i] = r[i] = 1; } for (int i = 1; i \u0026lt; n; i++) { if (ratings[i] \u0026gt; ratings[i-1]) { l[i] = l[i-1] + 1; } } int ans = l[n-1]; for (int i = n-2; i \u0026gt;= 0; i--) { if (ratings[i] \u0026gt; ratings[i+1]) { r[i] = r[i+1] + 1; } ans += max(l[i], r[i]); } return ans; } }; ","date":"2021-11-08T21:37:29+08:00","permalink":"https://hh02.github.io/p/leetcode-135.-candy/","title":"LeetCode 135. Candy"},{"content":"题目 A peak element is an element that is strictly greater than its neighbors.\nGiven an integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.\nYou may imagine that nums[-1] = nums[n] = -∞.\nYou must write an algorithm that runs in O(log n) time.\nExample 1:\nInput: nums = [1,2,3,1] Output: 2 Explanation: 3 is a peak element and your function should return the index number 2. 思路 我以前一直以为必须单调的数组才能用二分查找，后来遇到 LeetCode 第33题，明白了只要每次能排除掉一半的选项也能用二分查找，再后来就遇到了这题，我才想明白，二分查找是每一确定一半的选项。\nl = 0, r = nums.size() - 1, 对于每个 mid，有三种情况：\nnums[mid-1] \u0026lt; nums[mid] \u0026gt; nums[mid+1]，直接返回答案； nums[mid] \u0026lt; nums[mid+1], 说明mid 到 mid + 1 是递增的，那么mid + 1 ~ r，之间肯定有答案，因为：若mid+1 ~ r 是单增的，则 r 就是峰，若不是单增的，则一定有一个峰； nums[mid-1] \u0026gt; nums[mid], 与2同理。 现在来证明若mid+1 ~ r 单增的，则 r 就是峰。\n若 mid+1 ~ r 是单增的, nums[r-1] \u0026lt; nums[r]，我们只要证明 nums[r] \u0026gt; nums[r+1] 就行了。\n我们可以证明无论 r 怎么变化，nums[r] 一定大于 nums[r+1]：\n初始时，r = n-1, nums[r+1] = -∞， 显然 nums[r] \u0026gt; nums[r+1]； 在中途迭代中 r = mid\u0026rsquo; - 1 的条件是 num[mid\u0026rsquo; - 1] \u0026gt; nums[mid\u0026rsquo;]，所以在迭代后 num[r] \u0026gt; nums[r + 1]。 证毕。\n代码 class Solution { public: int findPeakElement(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); auto get = [\u0026amp;](int i) -\u0026gt; pair\u0026lt;int, int\u0026gt; { if (i == -1 || i == n) { return {0, 0}; } return {1, nums[i]}; }; int left = 0, right = n - 1, ans = -1; while (left \u0026lt;= right) { int mid = (left + right) / 2; if (get(mid - 1) \u0026lt; get(mid) \u0026amp;\u0026amp; get(mid) \u0026gt; get(mid + 1)) { ans = mid; break; } if (get(mid) \u0026lt; get(mid + 1)) { left = mid + 1; } else { right = mid - 1; } } return ans; } }; ","date":"2021-11-06T16:25:03+08:00","permalink":"https://hh02.github.io/p/leetcode-162.-find-peak-element/","title":"LeetCode 162. Find Peak Element"},{"content":"题目 A valid parentheses string is either empty \u0026ldquo;\u0026rdquo;, \u0026ldquo;(\u0026rdquo; + A + \u0026ldquo;)\u0026rdquo;, or A + B, where A and B are valid parentheses strings, and + represents string concatenation.\nFor example, \u0026ldquo;\u0026rdquo;, \u0026ldquo;()\u0026rdquo;, \u0026ldquo;(())()\u0026rdquo;, and \u0026ldquo;(()(()))\u0026rdquo; are all valid parentheses strings. A valid parentheses string s is primitive if it is nonempty, and there does not exist a way to split it into s = A + B, with A and B nonempty valid parentheses strings.\nGiven a valid parentheses string s, consider its primitive decomposition: s = P1 + P2 + \u0026hellip; + Pk, where Pi are primitive valid parentheses strings.\nReturn s after removing the outermost parentheses of every primitive string in the primitive decomposition of s.\nExample 1:\nInput: s = \u0026#34;(()())(())\u0026#34; Output: \u0026#34;()()()\u0026#34; Explanation: The input string is \u0026#34;(()())(())\u0026#34;, with primitive decomposition \u0026#34;(()())\u0026#34; + \u0026#34;(())\u0026#34;. After removing outer parentheses of each part, this is \u0026#34;()()\u0026#34; + \u0026#34;()\u0026#34; = \u0026#34;()()()\u0026#34;. 思路 可以发现最外层的括号在退栈后栈会空，所以记录空栈时括号对的 index，然后删除就可以了。\n代码 class Solution { public: string removeOuterParentheses(string s) { int n = s.size(); int t1 = -1, t2 = -1; stack\u0026lt;int\u0026gt; stk; bool d[n + 1]; memset(d, 0, sizeof(d)); for (int i = 0; i \u0026lt; n; i++) { if (s[i] == \u0026#39;(\u0026#39;) { stk.push(i); } else { int t = stk.top(); stk.pop(); if (stk.empty()) { d[i] = d[t] = true; } } } string ans; for (int i = 0; i \u0026lt; n; i++) { if (!d[i]) { ans.push_back(s[i]); } } return ans; } }; ","date":"2021-11-04T12:31:52+08:00","permalink":"https://hh02.github.io/p/leetcode-1021.-remove-outermost-parentheses/","title":"LeetCode 1021. Remove Outermost Parentheses"},{"content":"题目 Given a string s, return the longest palindromic substring in s.\nExample 1:\nInput: s = \u0026#34;babad\u0026#34; Output: \u0026#34;bab\u0026#34; Note: \u0026#34;aba\u0026#34; is also a valid answer. 思路 方法一：动态规划\nf[i][j] = true 表示 i~j 的字串为回文串，否则不是；\n转移：f[i][j] = (s[i] == s[j]) \u0026amp;\u0026amp; (f[i+1][j-1])\n方法二：中心扩展法\n是枚举所有回文中心并尝试扩展，需要注意的点是回文串的长度有可能是奇数也可能是偶数，回文中心不一样。\n方法三：Manacher 算法\n待填坑……\n代码 动态规划实现\nclass Solution { public: string longestPalindrome(string s) { int n = s.size(); bool f[n][n]; memset(f, 0, sizeof(f)); for (int i = 0; i \u0026lt; n; i++) f[i][i] = true; for (int i = 0; i + 1 \u0026lt; n; i++) { if (s[i] == s[i+1]) f[i][i+1] = true; } for (int l = 3; l \u0026lt;= n; l++) { for (int i = 0; ; i++) { int j = i + l - 1; if (j \u0026gt;= n) break; f[i][j] = (s[i] == s[j]) \u0026amp;\u0026amp; (f[i+1][j-1]); } } for (int l = n; l; l--) { for (int i = 0; ; i++) { int j = i + l - 1; if (j \u0026gt;= n) break; if (f[i][j]) return s.substr(i, j-i+1); } } return s.substr(0, 1); } }; ","date":"2021-10-28T19:54:02+08:00","permalink":"https://hh02.github.io/p/leetcode-5.-longest-palindromic-substring/","title":"LeetCode 5. Longest Palindromic Substring"},{"content":"题目 Given a string containing just the characters \u0026lsquo;(\u0026rsquo; and \u0026lsquo;)\u0026rsquo;, find the length of the longest valid (well-formed) parentheses substring.\nExample:\nInput: s = \u0026#34;)()())\u0026#34; Output: 4 Explanation: The longest valid parentheses substring is \u0026#34;()()\u0026#34;. 思路 对于遇到的每个 ( ，我们将它的下标放入栈中 对于遇到的每个 ) ，我们先弹出栈顶元素表示匹配了当前右括号： 如果栈为空，说明当前的右括号为没有被匹配的右括号，我们将其下标放入栈中来更新我们之前提到的「最后一个没有被匹配的右括号的下标」 如果栈不为空，当前右括号的下标减去栈顶元素即为「以该右括号为结尾的最长有效括号的长度」 还有动态规划算法和另一种算法，待填坑……\n代码 class Solution { public: int longestValidParentheses(string s) { stack\u0026lt;int\u0026gt; stk; stk.push(-1); int ans = 0; for (int i = 0; i \u0026lt; s.size(); i++) { if (s[i] == \u0026#39;(\u0026#39;) { stk.push(i); } else { stk.pop(); if (stk.empty()) { stk.push(i); } else { ans = max(ans, i - stk.top()); } } } return ans; } }; ","date":"2021-10-27T22:57:22+08:00","permalink":"https://hh02.github.io/p/leetcode-32.-longest-valid-parentheses/","title":"LeetCode 32. Longest Valid Parentheses"},{"content":"题目 Implement strStr().\nReturn the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\nClarification:\nWhat should we return when needle is an empty string? This is a great question to ask during an interview.\nFor the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C\u0026rsquo;s strstr() and Java\u0026rsquo;s indexOf().\nExample 1:\nInput: haystack = \u0026#34;hello\u0026#34;, needle = \u0026#34;ll\u0026#34; Output: 2 思路 KMP算法的模板题，终于会写 KMP啦！！！\n代码 class Solution { public: int strStr(string haystack, string needle) { int m = haystack.size(), n = needle.size(); if (!n) return 0; int nxt[n+10]; nxt[0] = -1; for (int i = 1, j = -1; i \u0026lt; n; i++) { while (j \u0026gt; -1 \u0026amp;\u0026amp; needle[i] != needle[j+1]) j = nxt[j]; if (needle[i] == needle[j+1]) j++; nxt[i] = j; } for (int i = 0, j = -1; i \u0026lt; m; i++) { while (j \u0026gt; -1 \u0026amp;\u0026amp; (j == n-1 || haystack[i] != needle[j+1])) j = nxt[j]; if (haystack[i] == needle[j+1]) j++; if (j == n - 1) { return i - n + 1; } } return -1; } }; ","date":"2021-10-26T17:05:34+08:00","permalink":"https://hh02.github.io/p/leetcode-28.-implement-strstr/","title":"LeetCode 28. Implement strStr()"},{"content":"题目 Write an efficient algorithm that searches for a target value in an m x n integer matrix. The matrix has the following properties:\nIntegers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom.\nExample 1:\n20211026164226 Input: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5 Output: true 思路 由题目可知，矩阵的每一行是递增的，每一列是递增的。\n从第一行的最后一个元素 matrix[i][j](i=0, j=n-1) 开始：\n若 target == matrix[i][j], 则返回 true； 若 target \u0026lt; matrix[i][j]， 则对于当前 j，所有 i\u0026rsquo; \u0026gt; i的元素 matrix[i\u0026rsquo;][j] \u0026gt; matrix[i][j], 所以可以排除掉 matrix[i~m-1][j]，matrix[0~i-1][j] 之前已经被排除掉了，所以 j\u0026ndash;; 若 target \u0026gt; matrix[i][j], 对于当前 i，所有 j\u0026rsquo; \u0026lt; j 的元素, matrix[i][j\u0026rsquo;] \u0026lt; matrix[i][j], 所以可以排除掉第 matrix[i][0~j], matrix[i][j+1~n-1]之前已经被排除掉了，所以 i++; 重复 1 ~ 3 直到 i \u0026gt; m 或者 j \u0026lt; 0。 主要思路就是每次可以排除一行或者一列。\n代码 class Solution { public: bool searchMatrix(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix, int target) { int m = matrix.size(); int n = matrix[0].size(); int i = 0, j = n - 1; while (i \u0026lt; m \u0026amp;\u0026amp; j \u0026gt;= 0) { if (target == matrix[i][j]) { return true; } if (target \u0026gt; matrix[i][j]) { i++; } else { j--; } } return false; } }; ","date":"2021-10-26T16:41:50+08:00","permalink":"https://hh02.github.io/p/leetcode-240.-search-a-2d-matrix-ii/","title":"LeetCode 240. Search a 2D Matrix II"},{"content":"题目 Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\nWe will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\nYou must solve this problem without using the library\u0026rsquo;s sort function.\nExample 1:\nInput: nums = [2,0,2,1,1,0] Output: [0,0,1,1,2,2] 思路 朴素的方法：第一遍遍历把所有0移动到最左端，第二遍遍历把所有1移动到0后面。\n改进一（双指针）：可以只遍历一遍，用两个指针p0, p1分别代表0的位置和1的位置，从左往右遍历遇到1将1交换到p1的位置，然后 p1++, 遇到0则将0交换到p0的位置，由于p0的位置上可能是1，如果是1还要再将1移动到p1的位置；然后 p0++, p1++；\n改进二（双指针）：遍历一遍，用p0, p2分别代表0和2的位置，从左往右遍历，遇到0则将0交换到p0的位置，然后p0向后移动一位，遇到2则将2交换到p2的位置，然后p2再向前移动一位，但是原来p2的位置可能是2，如果是2还要再将2交换到p2的位置，直到不是2为止。\n代码 改进一\nclass Solution { public: void sortColors(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); int p0 = 0, p1 = 0; for (int i = 0; i \u0026lt; n; i++) { if (nums[i] == 1) { swap(nums[i], nums[p1]); p1++; } else if (nums[i] == 0) { swap(nums[i], nums[p0]); if (p0 \u0026lt; p1) { swap(nums[i], nums[p1]); } ++p0; ++p1; } } } }; 改进二\nclass Solution { public: void sortColors(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); int p0 = 0, p2 = n - 1; for (int i = 0; i \u0026lt;= p2; i++) { while (i \u0026lt;= p2 \u0026amp;\u0026amp; nums[i] == 2) { swap(nums[i], nums[p2--]); } if (nums[i] == 0) { swap(nums[i], nums[p0++]); } } } }; ","date":"2021-10-25T17:14:15+08:00","permalink":"https://hh02.github.io/p/leetcode-75.-sort-colors/","title":"LeetCode 75. Sort Colors"},{"content":"题目 Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:\nIntegers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row.\nExample 1:\n20211025170139 Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3 Output: true 思路 思路一：先对第一列进行二分查找，再对行进行二分查找；\n思路二：将整个矩阵看作一个长为 m * n 的单调上升数组。\n代码 用的是思路二：\nclass Solution { public: bool searchMatrix(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix, int target) { int m = matrix.size(), n = matrix[0].size(); int low = 0, high = m * n - 1; while (low \u0026lt;= high) { int mid = (low + high) \u0026gt;\u0026gt; 1; int x = matrix[mid / n][mid % n]; if (x \u0026lt; target) { low = mid + 1; } else if (x \u0026gt; target) { high = mid - 1; } else { return true; } } return false; } }; ","date":"2021-10-25T17:00:43+08:00","permalink":"https://hh02.github.io/p/leetcode-74.-search-a-2d-matrix/","title":"LeetCode 74. Search a 2D Matrix"},{"content":"题目 There is an integer array nums sorted in ascending order (with distinct values).\nPrior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 \u0026lt;= k \u0026lt; nums.length) such that the resulting array is [nums[k], nums[k+1], \u0026hellip;, nums[n-1], nums[0], nums[1], \u0026hellip;, nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].\nGiven the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\nYou must write an algorithm with O(log n) runtime complexity.\nExample 1:\nInput: nums = [4,5,6,7,0,1,2], target = 0 Output: 4 思路 虽然不是完全单调，但是还是可以用二分。\n设在[l, r] 区间上搜索, mid = (l + r) / 2, 由于整个数组上只有一个跳跃点，且跳跃点右侧的值都是小于跳跃点左侧的值。在这个跳跃点左侧的区间，右侧的区间都是单调的，mid 要么在跳跃点的左侧要么在跳跃点的右侧。\n若 nums[mid] == target，则 mid 就是答案。 若 nums[mid] \u0026gt; nums[0], 那么 mid 必然在左单调区间，因为右单调区间的值都是小于左单调区间的值的。1. 如果 nums[0] \u0026lt;= target \u0026lt;= nums[mid] 说明 target 不在 [mid + 1, r] 上， 排除一半的搜索范围；2. 否则，target 不在 [l, mid] 上同样排除一半的搜索空间。 若 nums[mid] \u0026lt; nums[0], 与2同理。 代码 class Solution { public: int search(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int n = nums.size(); int l = 0, r = n-1, mid; while (l \u0026lt;= r) { mid = (l + r) \u0026gt;\u0026gt; 1; if (nums[mid] == target) { return mid; } if (nums[0] \u0026lt;= nums[mid]) { if (nums[0] \u0026lt;= target \u0026amp;\u0026amp; target \u0026lt;= nums[mid]) { r = mid - 1; } else { l = mid + 1; } } else { if (nums[mid] \u0026lt;= target \u0026amp;\u0026amp; target \u0026lt;= nums[n-1]) { l = mid + 1; } else { r = mid - 1; } } } return -1; } }; ","date":"2021-10-25T16:47:56+08:00","permalink":"https://hh02.github.io/p/leetcode-33.-search-in-rotated-sorted-array/","title":"LeetCode 33. Search in Rotated Sorted Array"},{"content":"2048. Next Greater Numerically Balanced Number 题目 An integer x is numerically balanced if for every digit d in the number x, there are exactly d occurrences of that digit in x.\nGiven an integer n, return the smallest numerically balanced number strictly greater than n.\nExample 1:\nInput: n = 1 Output: 22 Explanation: 22 is numerically balanced since: - The digit 2 occurs 2 times. It is also the smallest numerically balanced number strictly greater than 1. 思路 思路一：可以直接从 n 开始暴力枚举判断。\n思路二：n 是 6 位数的，所以可以先把 7 位数以内所有的结果构造出来，然后用二分查找，这种解法速度更快。\n代码 用的是思路二：\nclass Solution { public: void dfs(int i, vector\u0026lt;int\u0026gt;\u0026amp; tmp, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; p) { if (i \u0026gt; 7) { p.push_back(tmp); return; } dfs(i+1, tmp, p); tmp.push_back(i); dfs(i+1, tmp, p); tmp.pop_back(); } void calc(int* c, long long num, vector\u0026lt;long long\u0026gt;\u0026amp; nums) { if (!c[1] \u0026amp;\u0026amp; !c[2] \u0026amp;\u0026amp; !c[3] \u0026amp;\u0026amp; !c[4] \u0026amp;\u0026amp; !c[5] \u0026amp;\u0026amp; !c[6] \u0026amp;\u0026amp; !c[7]) { nums.push_back(num); return; } for (int i = 1; i \u0026lt;= 7; i++) { if (c[i]) { c[i]--; calc(c, num*10 + i, nums); c[i]++; } } } int nextBeautifulNumber(int n) { vector\u0026lt;int\u0026gt; tmp; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; p; dfs(1, tmp, p); vector\u0026lt;long long\u0026gt; nums; for (const auto\u0026amp; t: p) { int c[10]; memset(c, 0, sizeof(c)); int sum = 0; for (const auto j: t) { sum += j; c[j] = j; } if (sum \u0026lt;= 8) calc(c, 0, nums); } sort(nums.begin(), nums.end()); int l = 0, r = nums.size() - 1, ans = 0; while (l \u0026lt;= r) { int mid = (l+r) / 2; if (nums[mid] \u0026gt; n) { ans = nums[mid]; r = mid - 1; } else { l = mid + 1; } } return ans; } }; ","date":"2021-10-25T15:22:51+08:00","permalink":"https://hh02.github.io/p/leetcode-weekly-contest-264/","title":"LeetCode Weekly Contest 264"},{"content":"题目 You are given an integer array nums. In one move, you can pick an index i where 0 \u0026lt;= i \u0026lt; nums.length and increment nums[i] by 1.\nReturn the minimum number of moves to make every value in nums unique.\nExample 1:\nInput: nums = [1,2,2] Output: 1 Explanation: After 1 move, the array could be [1, 2, 3]. 思路 遍历 nums 数组，遇到有重复的数字，加到不重复为止。\n这个于哈希有点类似，当遇到重复时候向后寻找空位，但是有可能超时，可以用路径压缩（类似于并查集）进行加速。比官方题解 NlogN 解法要快一点。\n代码 class Solution { public: int find(int x, int* d) { if (d[x + d[x]] != 0) { d[x] += find(x + d[x], d); } return d[x]; } int minIncrementForUnique(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = *max_element(nums.begin(), nums.end()); int d[n * 2 + 10]; memset(d, 0, sizeof(d)); int ans = 0; for (const auto\u0026amp; t: nums) { int p = find(t, d); ans += p; d[t + p] = 1; } return ans; } }; ","date":"2021-10-25T15:13:52+08:00","permalink":"https://hh02.github.io/p/leetcode-945.-minimum-increment-to-make-array-unique/","title":"LeetCode 945. Minimum Increment to Make Array Unique"},{"content":"题目 Given the head of a singly linked list, reverse the list, and return the reversed list.\nExample 1:\n20211023233452 Input: head = [1,2,3,4,5] Output: [5,4,3,2,1] 思路 有迭代和递归两种写法。\n代码 迭代 class Solution { public: ListNode* reverseList(ListNode* head) { if (head == nullptr) return nullptr; ListNode* p1 = nullptr; ListNode* p2 = head; ListNode* p3; while(p2) { p3 = p2-\u0026gt;next; p2-\u0026gt;next = p1; p1 = p2; p2 = p3; } return p1; } }; 递归 class Solution { public: ListNode* reverseList(ListNode* head) { if (!head || !head-\u0026gt;next) { return head; } ListNode* newHead = reverseList(head-\u0026gt;next); head-\u0026gt;next-\u0026gt;next = head; head-\u0026gt;next = nullptr; return newHead; } }; ","date":"2021-10-23T23:21:59+08:00","permalink":"https://hh02.github.io/p/leetcode-206.-reverse-linked-list/","title":"LeetCode 206. Reverse Linked List"},{"content":"题目 Given an n x n matrix where each of the rows and columns are sorted in ascending order, return the kth smallest element in the matrix.\nNote that it is the kth smallest element in the sorted order, not the kth distinct element.\n思路 二分查找。查找比 mid 小的有多少个。因为矩阵是有序的，所以可以很快计算出来比 mid 小的有多少。所以速度很快。\n代码 class Solution { public: bool check(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix, int mid, int k, int n) { int i = n - 1; int j = 0; int num = 0; while (i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt; n) { if (matrix[i][j] \u0026lt;= mid) { num += i + 1; j++; } else { i--; } } return num \u0026gt;= k; } int kthSmallest(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix, int k) { int n = matrix.size(); int l = matrix[0][0]; int r = matrix[n-1][n-1]; while (l \u0026lt; r) { int mid = l + (r - l) / 2; if (check(matrix, mid, k, n)) { r = mid; } else { l = mid + 1; } } return l; } }; ","date":"2021-10-22T23:03:34+08:00","permalink":"https://hh02.github.io/p/leetcode-378.-kth-smallest-element-in-a-sorted-matrix/","title":"LeetCode 378. Kth Smallest Element in a Sorted Matrix"},{"content":"38.外观数列 class Solution { public: string countAndSay(int n) { if (n == 1) { return \u0026#34;1\u0026#34;; } string t1 = \u0026#34;1\u0026#34;; string t2 = \u0026#34;\u0026#34;; for (int i = 2; i \u0026lt;= n; i++) { int j = 0; int len = t1.size(); while (j \u0026lt; len) { int cnt = 1; while (j + 1 \u0026lt; len \u0026amp;\u0026amp; t1[j] == t1[j+1]) { j++; cnt++; } t2 += to_string(cnt); t2 += t1[j]; j++; } swap(t1, t2); t2 = \u0026#34;\u0026#34;; } return t1; } }; 39.组合总和 class Solution { public: void dfs(int i, vector\u0026lt;int\u0026gt;\u0026amp; tmp, int target, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;ans, const vector\u0026lt;int\u0026gt;\u0026amp; candidates) { if (target == 0) { ans.push_back(tmp); return; } if (i \u0026gt;= candidates.size() || target \u0026lt; candidates[i]) { return; } tmp.push_back(candidates[i]); dfs(i, tmp, target-candidates[i], ans, candidates); tmp.pop_back(); dfs(i + 1, tmp, target, ans, candidates); } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; combinationSum(vector\u0026lt;int\u0026gt;\u0026amp; candidates, int target) { sort(candidates.begin(), candidates.end()); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; vector\u0026lt;int\u0026gt; tmp; dfs(0, tmp, target, ans, candidates); return ans; } }; 40.组合总和-ii class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; combinationSum2(vector\u0026lt;int\u0026gt;\u0026amp; candidates, int target) { int cnt[51]; memset(cnt, 0, sizeof(cnt)); for (const auto\u0026amp; t: candidates) { cnt[t]++; } sort(candidates.begin(), candidates.end()); int m = unique(candidates.begin(), candidates.end()) - candidates.begin(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; vector\u0026lt;int\u0026gt; tmp; dfs(0, tmp, target, ans, candidates, m, cnt); return ans; } void dfs(int i, vector\u0026lt;int\u0026gt;\u0026amp; tmp, int target, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;ans, const vector\u0026lt;int\u0026gt;\u0026amp; candidates, int m, int* cnt) { if (target == 0) { ans.push_back(tmp); return; } if (i \u0026gt;= m || target \u0026lt; candidates[i]) { return; } if (cnt[candidates[i]]) { tmp.push_back(candidates[i]); cnt[candidates[i]]--; dfs(i, tmp, target-candidates[i], ans, candidates, m, cnt); tmp.pop_back(); cnt[candidates[i]]++; } dfs(i + 1, tmp, target, ans, candidates, m, cnt); } }; ","date":"2021-10-11T19:30:44+08:00","permalink":"https://hh02.github.io/p/leetcode%E5%88%B7%E9%A2%9820211011/","title":"LeetCode刷题20211011"},{"content":"29 两数相除 要求不使用乘法、除法和 mod 运算符。\nclass Solution { public: int divide(int dividend, int divisor) { if (dividend == 0) return 0; if (divisor == 1) return dividend; if (divisor == -1) { if (dividend \u0026gt; INT_MIN) return -dividend; return INT_MAX; } long long a = dividend; long long b = divisor; int sign = 1; if ((a \u0026gt; 0 \u0026amp;\u0026amp; b \u0026lt; 0) || (a \u0026lt; 0 \u0026amp;\u0026amp; b \u0026gt; 0)) { sign = -1; } a = a \u0026gt; 0 ? a : -a; b = b \u0026gt; 0 ? b : -b; long long ret = calc(a, b); if (sign \u0026gt; 0) return ret \u0026gt; INT_MAX? INT_MAX: ret; return -ret; } int calc(long long a, long long b) { if (a \u0026lt; b) return 0; long long cnt = 1; long long tb = b; while (tb \u0026lt;= a) { tb \u0026lt;\u0026lt;= 1; cnt \u0026lt;\u0026lt;= 1; } tb \u0026gt;\u0026gt;= 1; cnt \u0026gt;\u0026gt;= 1; return cnt + calc(a - tb, b); } }; 31. 下一个排列 从右往左找第一个 a[i] \u0026lt; a[i+1] 的，然后翻转 [i+1, n);\nclass Solution { public: void nextPermutation(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int i = nums.size() - 2; while (i \u0026gt;= 0 \u0026amp;\u0026amp; nums[i] \u0026gt;= nums[i + 1]) { i--; } if (i \u0026gt;= 0) { int j = nums.size() - 1; while (j \u0026gt;= 0 \u0026amp;\u0026amp; nums[i] \u0026gt;= nums[j]) { j--; } swap(nums[i], nums[j]); } reverse(nums.begin() + i + 1, nums.end()); } }; 33.搜索旋转排序数组 这题居然可以用二分！！!\n只要对二分修改一下就行：\n因为整个数组只有一个不单调点，要么在左区间[l, mid]，要么在右区间[mid+1, r]，所以有且只有一个区间是单调的，也就是说区间左端点的值小于右端点的值。对于这个单调的区间，可以判断 target 是否在这个区间，这样每次就可以排除一半的区间。\nclass Solution { public: int search(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int n = nums.size(); if (!n) return -1; if (n == 1) { return nums[0] == target ? 0 : -1; } int l = 0, r = n - 1; while (l \u0026lt;= r) { int mid = (l + r) / 2; if (nums[mid] == target) return mid; if (nums[0] \u0026lt;= nums[mid]) { if (nums[0] \u0026lt;= target \u0026amp;\u0026amp; target \u0026lt; nums[mid]) { r = mid -1; } else { l = mid + 1; } } else { if (nums[mid] \u0026lt; target \u0026amp;\u0026amp; target \u0026lt;= nums[n-1]) { l = mid + 1; } else { r = mid - 1; } } } return -1; } }; 34.在排序数组中查找元素的第一个和最后一个位置 这题可以用 lower_bound 和 upper_bound 做，若存在 target，lower_bound 返回的是第一个 target 的位置， upper_bound 返回的是最后一个 target 的位置的后一个位置，正好是一个左闭右开的区间：[l, r)。\nclass Solution { public: vector\u0026lt;int\u0026gt; searchRange(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int n = nums.size(); if (!n) { return {-1, -1}; } int pos = lower_bound(nums.begin(), nums.end(), target) - nums.begin(); if (pos \u0026gt;= n || pos \u0026lt; 0 || nums[pos] != target) { return {-1, -1}; } int pos2 = upper_bound(nums.begin(), nums.end(), target) - nums.begin() - 1; return {pos, pos2}; } }; 36.有效的数独 九宫格的位置可以计算出来，不用这么麻烦的判断。\nclass Solution { public: int calc(int i, int j) { if (i \u0026lt; 3) { if (j \u0026lt; 3) return 0; if (j \u0026lt; 6) return 1; if (j \u0026lt; 9) return 2; } if (i \u0026lt; 6) { if (j \u0026lt; 3) return 3; if (j \u0026lt; 6) return 4; if (j \u0026lt; 9) return 5; } if (j \u0026lt; 3) return 6; if (j \u0026lt; 6) return 7; return 8; } bool isValidSudoku(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board) { bool area[10][10], row[10][10], col[10][10]; memset(area, 0, sizeof(area)); memset(row, 0, sizeof(row)); memset(col, 0, sizeof(col)); for (int i = 0; i \u0026lt; 9; i++) { for (int j = 0; j \u0026lt; 9; j++) { if (board[i][j] \u0026lt; \u0026#39;0\u0026#39; || board[i][j] \u0026gt; \u0026#39;9\u0026#39;) continue; int tmp = board[i][j] - \u0026#39;0\u0026#39;; int a = calc(i, j); if (area[a][tmp]) return false; if (row[i][tmp]) return false; if (col[j][tmp]) return false; area[a][tmp] = row[i][tmp] = col[j][tmp] = true; } } } }; ","date":"2021-10-10T22:54:10+08:00","permalink":"https://hh02.github.io/p/leetcode%E5%88%B7%E9%A2%982021-10-10/","title":"LeetCode刷题2021 10 10"},{"content":" 题目 题目难度 提交次数 #14 最长公共前缀 简单 1 次 #13 罗马数字转整数 简单 3 次 #12 整数转罗马数字 中等 2 次 #11 盛最多水的容器 中等 1 次 #9 回文数 简单 1 次 #8 字符串转换整数 (atoi) 中等 7 次 #7 整数反转 简单 5 次 #6 Z 字形变换 中等 3 次 6. Z 字形变换 方法一：迭代，将每个字符放到对应行，然后输出。\n方法二：找每一行的字符对应的索引\n7. 整数反转 ret * 10 + digit \u0026lt;= INT_MAX\n$$ ret \u0026lt;= \\lfloor \\frac{intmax-digit}{10} \\rfloor $$\nret * 10 + dight \u0026lt;= INT_MAX / 10 * 10 + INT_MAX % 10\n(ret - INT_MAX / 10) * 10 \u0026lt;= 7 - digit\n若 ret \u0026gt; INT_MAX / 10, 不等式不成立\n若 ret == INT_MAX / 10，在 digit \u0026lt;= 7 时成立，因为 int 首位最大是2, 所以成立\n若 ret \u0026lt; INT_MAX / 10, 不等式成立\n所以比较 ret 和 INT_MAX / 10 可防止溢出。\n8. 字符串转换整数 (atoi) 自动机，但我是直接模拟的。\n9. 回文数 class Solution { public: bool isPalindrome(int x) { if (x \u0026lt; 0 || (x % 10 == 0 \u0026amp;\u0026amp; x != 0)) { return false; } int revertedNumber = 0; while (x \u0026gt; revertedNumber) { // 这一行的判断方法很好！ revertedNumber = revertedNumber * 10 + x % 10; x /= 10; } return x == revertedNumber || x == revertedNumber / 10; } }; 11. 盛最多水的容器 双指针法，减小了搜索空间。每次排除不可能是最优解的。\nhttps://leetcode-cn.com/problems/container-with-most-water/solution/on-shuang-zhi-zhen-jie-fa-li-jie-zheng-que-xing-tu/\nclass Solution { public: int maxArea(vector\u0026lt;int\u0026gt;\u0026amp; height) { int l = 0, r = height.size() - 1; int ans = 0; while (l \u0026lt; r) { int area = min(height[l], height[r]) * (r - l); ans = max(ans, area); if (height[l] \u0026lt;= height[r]) l++; else r--; } return ans; } }; ","date":"2021-10-08T23:21:36+08:00","permalink":"https://hh02.github.io/p/leetcode%E5%88%B7%E9%A2%982021-10-8/","title":"LeetCode刷题2021 10 8"}]