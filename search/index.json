[{"content":"题目 Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.\nNote that the same word in the dictionary may be reused multiple times in the segmentation.\nExample 1:\nInput: s = \u0026#34;leetcode\u0026#34;, wordDict = [\u0026#34;leet\u0026#34;,\u0026#34;code\u0026#34;] Output: true Explanation: Return true because \u0026#34;leetcode\u0026#34; can be segmented as \u0026#34;leet code\u0026#34;. 思路 动态规划，dp[i] = dp[j] \u0026amp;\u0026amp; check(j+1, i);\n其中 check 用来检查某一个字串是否在dictSet中， dictSet 可以用stl库中的set（或者unordered_set)。\n代码 class Solution { public: bool wordBreak(string s, vector\u0026lt;string\u0026gt;\u0026amp; wordDict) { auto wordDictSet = unordered_set \u0026lt;string\u0026gt; (); for (auto word: wordDict) { wordDictSet.insert(word); } bool dp[s.size() + 1]; memset(dp, 0, sizeof(dp)); dp[0] = true; for (int i = 1; i \u0026lt;= s.size(); i++) { for (int j = 0; j \u0026lt; i; j++) { if (dp[j] \u0026amp;\u0026amp; wordDictSet.find(s.substr(j, i-j)) != wordDictSet.end()) { dp[i] = true; break; } } } return dp[s.size()]; } }; ","date":"2021-11-22T22:23:26+08:00","permalink":"https://hh02.github.io/p/leetcode-139.-word-break/","title":"LeetCode 139. Word Break"},{"content":"题目 Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\nNotice that the solution set must not contain duplicate triplets.\n思路 与 2sum 类似，先对数组进行排序，枚举前两个数，第三个数是单减的。注意不要枚举重复了。\n代码 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; threeSum(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); sort(nums.begin(), nums.end()); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; for (int i = 0; i \u0026lt; n; i++) { if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i-1]) continue; int k = n - 1; int target = -nums[i]; for (int j = i + 1; j \u0026lt; n; j++) { if (j \u0026gt; i + 1 \u0026amp;\u0026amp; nums[j] == nums[j-1]) continue; while (j \u0026lt; k \u0026amp;\u0026amp; nums[j] + nums[k] \u0026gt; target) k--; if (k == j) break; if (nums[j] + nums[k] == target) { ans.push_back({nums[i], nums[j], nums[k]}); } } } return ans; } }; ","date":"2021-11-15T23:56:08+08:00","permalink":"https://hh02.github.io/p/leetcode-15.-3sum/","title":"LeetCode 15. 3Sum"},{"content":"题目 There are n children standing in a line. Each child is assigned a rating value given in the integer array ratings.\nYou are giving candies to these children subjected to the following requirements:\nEach child must have at least one candy. Children with a higher rating get more candies than their neighbors. Return the minimum number of candies you need to have to distribute the candies to the children.\nExample 1:\nInput: ratings = [1,0,2] Output: 5 Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively. 思路 一开始的思路是首先最小值的糖果数是 1，因为没有比它更小的了，然后再去确定次小值。这样直接对原数组排序，从小往大去更新。这样做的时间复杂度是 nlogn。\n后来看了题解，有更优的做法。设第 i 个人的糖果个数为 cnt[i], 想了半天也没想明白……\n代码 class Solution { public: int candy(vector\u0026lt;int\u0026gt;\u0026amp; ratings) { int n = ratings.size(); int l[n+1], r[n+1]; for (int i = 0; i \u0026lt; n; i++) { l[i] = r[i] = 1; } for (int i = 1; i \u0026lt; n; i++) { if (ratings[i] \u0026gt; ratings[i-1]) { l[i] = l[i-1] + 1; } } int ans = l[n-1]; for (int i = n-2; i \u0026gt;= 0; i--) { if (ratings[i] \u0026gt; ratings[i+1]) { r[i] = r[i+1] + 1; } ans += max(l[i], r[i]); } return ans; } }; ","date":"2021-11-08T21:37:29+08:00","permalink":"https://hh02.github.io/p/leetcode-135.-candy/","title":"LeetCode 135. Candy"},{"content":"题目 A peak element is an element that is strictly greater than its neighbors.\nGiven an integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.\nYou may imagine that nums[-1] = nums[n] = -∞.\nYou must write an algorithm that runs in O(log n) time.\nExample 1:\nInput: nums = [1,2,3,1] Output: 2 Explanation: 3 is a peak element and your function should return the index number 2. 思路 我以前一直以为必须单调的数组才能用二分查找，后来遇到 LeetCode 第33题，明白了只要每次能排除掉一半的选项也能用二分查找，再后来就遇到了这题，我才想明白，二分查找是每一确定一半的选项。\nl = 0, r = nums.size() - 1, 对于每个 mid，有三种情况：\n nums[mid-1] \u0026lt; nums[mid] \u0026gt; nums[mid+1]，直接返回答案； nums[mid] \u0026lt; nums[mid+1], 说明mid 到 mid + 1 是递增的，那么mid + 1 ~ r，之间肯定有答案，因为：若mid+1 ~ r 是单增的，则 r 就是峰，若不是单增的，则一定有一个峰； nums[mid-1] \u0026gt; nums[mid], 与2同理。  现在来证明若mid+1 ~ r 单增的，则 r 就是峰。\n若 mid+1 ~ r 是单增的, nums[r-1] \u0026lt; nums[r]，我们只要证明 nums[r] \u0026gt; nums[r+1] 就行了。\n我们可以证明无论 r 怎么变化，nums[r] 一定大于 nums[r+1]：\n 初始时，r = n-1, nums[r+1] = -∞， 显然 nums[r] \u0026gt; nums[r+1]； 在中途迭代中 r = mid' - 1 的条件是 num[mid' - 1] \u0026gt; nums[mid']，所以在迭代后 num[r] \u0026gt; nums[r + 1]。  证毕。\n代码 class Solution { public: int findPeakElement(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); auto get = [\u0026amp;](int i) -\u0026gt; pair\u0026lt;int, int\u0026gt; { if (i == -1 || i == n) { return {0, 0}; } return {1, nums[i]}; }; int left = 0, right = n - 1, ans = -1; while (left \u0026lt;= right) { int mid = (left + right) / 2; if (get(mid - 1) \u0026lt; get(mid) \u0026amp;\u0026amp; get(mid) \u0026gt; get(mid + 1)) { ans = mid; break; } if (get(mid) \u0026lt; get(mid + 1)) { left = mid + 1; } else { right = mid - 1; } } return ans; } }; ","date":"2021-11-06T16:25:03+08:00","permalink":"https://hh02.github.io/p/leetcode-162.-find-peak-element/","title":"LeetCode 162. Find Peak Element"},{"content":"题目 A valid parentheses string is either empty \u0026ldquo;\u0026rdquo;, \u0026ldquo;(\u0026rdquo; + A + \u0026ldquo;)\u0026rdquo;, or A + B, where A and B are valid parentheses strings, and + represents string concatenation.\nFor example, \u0026ldquo;\u0026rdquo;, \u0026ldquo;()\u0026rdquo;, \u0026ldquo;(())()\u0026rdquo;, and \u0026ldquo;(()(()))\u0026rdquo; are all valid parentheses strings. A valid parentheses string s is primitive if it is nonempty, and there does not exist a way to split it into s = A + B, with A and B nonempty valid parentheses strings.\nGiven a valid parentheses string s, consider its primitive decomposition: s = P1 + P2 + \u0026hellip; + Pk, where Pi are primitive valid parentheses strings.\nReturn s after removing the outermost parentheses of every primitive string in the primitive decomposition of s.\nExample 1:\nInput: s = \u0026#34;(()())(())\u0026#34; Output: \u0026#34;()()()\u0026#34; Explanation: The input string is \u0026#34;(()())(())\u0026#34;, with primitive decomposition \u0026#34;(()())\u0026#34; + \u0026#34;(())\u0026#34;. After removing outer parentheses of each part, this is \u0026#34;()()\u0026#34; + \u0026#34;()\u0026#34; = \u0026#34;()()()\u0026#34;. 思路 可以发现最外层的括号在退栈后栈会空，所以记录空栈时括号对的 index，然后删除就可以了。\n代码 class Solution { public: string removeOuterParentheses(string s) { int n = s.size(); int t1 = -1, t2 = -1; stack\u0026lt;int\u0026gt; stk; bool d[n + 1]; memset(d, 0, sizeof(d)); for (int i = 0; i \u0026lt; n; i++) { if (s[i] == \u0026#39;(\u0026#39;) { stk.push(i); } else { int t = stk.top(); stk.pop(); if (stk.empty()) { d[i] = d[t] = true; } } } string ans; for (int i = 0; i \u0026lt; n; i++) { if (!d[i]) { ans.push_back(s[i]); } } return ans; } }; ","date":"2021-11-04T12:31:52+08:00","permalink":"https://hh02.github.io/p/leetcode-1021.-remove-outermost-parentheses/","title":"LeetCode 1021. Remove Outermost Parentheses"},{"content":"题目 Given a string s, return the longest palindromic substring in s.\nExample 1:\nInput: s = \u0026#34;babad\u0026#34; Output: \u0026#34;bab\u0026#34; Note: \u0026#34;aba\u0026#34; is also a valid answer. 思路 方法一：动态规划\nf[i][j] = true 表示 i~j 的字串为回文串，否则不是；\n转移：f[i][j] = (s[i] == s[j]) \u0026amp;\u0026amp; (f[i+1][j-1])\n方法二：中心扩展法\n是枚举所有回文中心并尝试扩展，需要注意的点是回文串的长度有可能是奇数也可能是偶数，回文中心不一样。\n方法三：Manacher 算法\n待填坑……\n代码 动态规划实现\nclass Solution { public: string longestPalindrome(string s) { int n = s.size(); bool f[n][n]; memset(f, 0, sizeof(f)); for (int i = 0; i \u0026lt; n; i++) f[i][i] = true; for (int i = 0; i + 1 \u0026lt; n; i++) { if (s[i] == s[i+1]) f[i][i+1] = true; } for (int l = 3; l \u0026lt;= n; l++) { for (int i = 0; ; i++) { int j = i + l - 1; if (j \u0026gt;= n) break; f[i][j] = (s[i] == s[j]) \u0026amp;\u0026amp; (f[i+1][j-1]); } } for (int l = n; l; l--) { for (int i = 0; ; i++) { int j = i + l - 1; if (j \u0026gt;= n) break; if (f[i][j]) return s.substr(i, j-i+1); } } return s.substr(0, 1); } }; ","date":"2021-10-28T19:54:02+08:00","permalink":"https://hh02.github.io/p/leetcode-5.-longest-palindromic-substring/","title":"LeetCode 5. Longest Palindromic Substring"},{"content":"题目 Given a string containing just the characters \u0026lsquo;(\u0026rsquo; and \u0026lsquo;)\u0026rsquo;, find the length of the longest valid (well-formed) parentheses substring.\nExample:\nInput: s = \u0026#34;)()())\u0026#34; Output: 4 Explanation: The longest valid parentheses substring is \u0026#34;()()\u0026#34;. 思路  对于遇到的每个 ( ，我们将它的下标放入栈中 对于遇到的每个 ) ，我们先弹出栈顶元素表示匹配了当前右括号：  如果栈为空，说明当前的右括号为没有被匹配的右括号，我们将其下标放入栈中来更新我们之前提到的「最后一个没有被匹配的右括号的下标」 如果栈不为空，当前右括号的下标减去栈顶元素即为「以该右括号为结尾的最长有效括号的长度」    还有动态规划算法和另一种算法，待填坑……\n代码 class Solution { public: int longestValidParentheses(string s) { stack\u0026lt;int\u0026gt; stk; stk.push(-1); int ans = 0; for (int i = 0; i \u0026lt; s.size(); i++) { if (s[i] == \u0026#39;(\u0026#39;) { stk.push(i); } else { stk.pop(); if (stk.empty()) { stk.push(i); } else { ans = max(ans, i - stk.top()); } } } return ans; } }; ","date":"2021-10-27T22:57:22+08:00","permalink":"https://hh02.github.io/p/leetcode-32.-longest-valid-parentheses/","title":"LeetCode 32. Longest Valid Parentheses"},{"content":"题目 Implement strStr().\nReturn the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\nClarification:\nWhat should we return when needle is an empty string? This is a great question to ask during an interview.\nFor the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C\u0026rsquo;s strstr() and Java\u0026rsquo;s indexOf().\nExample 1:\nInput: haystack = \u0026#34;hello\u0026#34;, needle = \u0026#34;ll\u0026#34; Output: 2 思路 KMP算法的模板题，终于会写 KMP啦！！！\n代码 class Solution { public: int strStr(string haystack, string needle) { int m = haystack.size(), n = needle.size(); if (!n) return 0; int nxt[n+10]; nxt[0] = -1; for (int i = 1, j = -1; i \u0026lt; n; i++) { while (j \u0026gt; -1 \u0026amp;\u0026amp; needle[i] != needle[j+1]) j = nxt[j]; if (needle[i] == needle[j+1]) j++; nxt[i] = j; } for (int i = 0, j = -1; i \u0026lt; m; i++) { while (j \u0026gt; -1 \u0026amp;\u0026amp; (j == n-1 || haystack[i] != needle[j+1])) j = nxt[j]; if (haystack[i] == needle[j+1]) j++; if (j == n - 1) { return i - n + 1; } } return -1; } }; ","date":"2021-10-26T17:05:34+08:00","permalink":"https://hh02.github.io/p/leetcode-28.-implement-strstr/","title":"LeetCode 28. Implement strStr()"},{"content":"题目 Write an efficient algorithm that searches for a target value in an m x n integer matrix. The matrix has the following properties:\nIntegers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom.\nExample 1:\n 20211026164226 \nInput: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5 Output: true 思路 由题目可知，矩阵的每一行是递增的，每一列是递增的。\n从第一行的最后一个元素 matrix[i][j](i=0, j=n-1) 开始：\n 若 target == matrix[i][j], 则返回 true； 若 target \u0026lt; matrix[i][j]， 则对于当前 j，所有 i' \u0026gt; i的元素 matrix[i'][j] \u0026gt; matrix[i][j], 所以可以排除掉 matrix[i~m-1][j]，matrix[0~i-1][j] 之前已经被排除掉了，所以 j\u0026ndash;; 若 target \u0026gt; matrix[i][j], 对于当前 i，所有 j' \u0026lt; j 的元素, matrix[i][j'] \u0026lt; matrix[i][j], 所以可以排除掉第 matrix[i][0~j], matrix[i][j+1~n-1]之前已经被排除掉了，所以 i++; 重复 1 ~ 3 直到 i \u0026gt; m 或者 j \u0026lt; 0。  主要思路就是每次可以排除一行或者一列。\n代码 class Solution { public: bool searchMatrix(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix, int target) { int m = matrix.size(); int n = matrix[0].size(); int i = 0, j = n - 1; while (i \u0026lt; m \u0026amp;\u0026amp; j \u0026gt;= 0) { if (target == matrix[i][j]) { return true; } if (target \u0026gt; matrix[i][j]) { i++; } else { j--; } } return false; } }; ","date":"2021-10-26T16:41:50+08:00","permalink":"https://hh02.github.io/p/leetcode-240.-search-a-2d-matrix-ii/","title":"LeetCode 240. Search a 2D Matrix II"},{"content":"题目 Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\nWe will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\nYou must solve this problem without using the library\u0026rsquo;s sort function.\nExample 1:\nInput: nums = [2,0,2,1,1,0] Output: [0,0,1,1,2,2] 思路 朴素的方法：第一遍遍历把所有0移动到最左端，第二遍遍历把所有1移动到0后面。\n改进一（双指针）：可以只遍历一遍，用两个指针p0, p1分别代表0的位置和1的位置，从左往右遍历遇到1将1交换到p1的位置，然后 p1++, 遇到0则将0交换到p0的位置，由于p0的位置上可能是1，如果是1还要再将1移动到p1的位置；然后 p0++, p1++；\n改进二（双指针）：遍历一遍，用p0, p2分别代表0和2的位置，从左往右遍历，遇到0则将0交换到p0的位置，然后p0向后移动一位，遇到2则将2交换到p2的位置，然后p2再向前移动一位，但是原来p2的位置可能是2，如果是2还要再将2交换到p2的位置，直到不是2为止。\n代码 改进一\nclass Solution { public: void sortColors(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); int p0 = 0, p1 = 0; for (int i = 0; i \u0026lt; n; i++) { if (nums[i] == 1) { swap(nums[i], nums[p1]); p1++; } else if (nums[i] == 0) { swap(nums[i], nums[p0]); if (p0 \u0026lt; p1) { swap(nums[i], nums[p1]); } ++p0; ++p1; } } } }; 改进二\nclass Solution { public: void sortColors(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); int p0 = 0, p2 = n - 1; for (int i = 0; i \u0026lt;= p2; i++) { while (i \u0026lt;= p2 \u0026amp;\u0026amp; nums[i] == 2) { swap(nums[i], nums[p2--]); } if (nums[i] == 0) { swap(nums[i], nums[p0++]); } } } }; ","date":"2021-10-25T17:14:15+08:00","permalink":"https://hh02.github.io/p/leetcode-75.-sort-colors/","title":"LeetCode 75. Sort Colors"},{"content":"题目 Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:\nIntegers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row.\nExample 1:\n 20211025170139 \nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3 Output: true 思路 思路一：先对第一列进行二分查找，再对行进行二分查找；\n思路二：将整个矩阵看作一个长为 m * n 的单调上升数组。\n代码 用的是思路二：\nclass Solution { public: bool searchMatrix(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix, int target) { int m = matrix.size(), n = matrix[0].size(); int low = 0, high = m * n - 1; while (low \u0026lt;= high) { int mid = (low + high) \u0026gt;\u0026gt; 1; int x = matrix[mid / n][mid % n]; if (x \u0026lt; target) { low = mid + 1; } else if (x \u0026gt; target) { high = mid - 1; } else { return true; } } return false; } }; ","date":"2021-10-25T17:00:43+08:00","permalink":"https://hh02.github.io/p/leetcode-74.-search-a-2d-matrix/","title":"LeetCode 74. Search a 2D Matrix"},{"content":"题目 There is an integer array nums sorted in ascending order (with distinct values).\nPrior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 \u0026lt;= k \u0026lt; nums.length) such that the resulting array is [nums[k], nums[k+1], \u0026hellip;, nums[n-1], nums[0], nums[1], \u0026hellip;, nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].\nGiven the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\nYou must write an algorithm with O(log n) runtime complexity.\nExample 1:\nInput: nums = [4,5,6,7,0,1,2], target = 0 Output: 4 思路 虽然不是完全单调，但是还是可以用二分。\n设在[l, r] 区间上搜索, mid = (l + r) / 2, 由于整个数组上只有一个跳跃点，且跳跃点右侧的值都是小于跳跃点左侧的值。在这个跳跃点左侧的区间，右侧的区间都是单调的，mid 要么在跳跃点的左侧要么在跳跃点的右侧。\n 若 nums[mid] == target，则 mid 就是答案。 若 nums[mid] \u0026gt; nums[0], 那么 mid 必然在左单调区间，因为右单调区间的值都是小于左单调区间的值的。1. 如果 nums[0] \u0026lt;= target \u0026lt;= nums[mid] 说明 target 不在 [mid + 1, r] 上， 排除一半的搜索范围；2. 否则，target 不在 [l, mid] 上同样排除一半的搜索空间。 若 nums[mid] \u0026lt; nums[0], 与2同理。  代码 class Solution { public: int search(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int n = nums.size(); int l = 0, r = n-1, mid; while (l \u0026lt;= r) { mid = (l + r) \u0026gt;\u0026gt; 1; if (nums[mid] == target) { return mid; } if (nums[0] \u0026lt;= nums[mid]) { if (nums[0] \u0026lt;= target \u0026amp;\u0026amp; target \u0026lt;= nums[mid]) { r = mid - 1; } else { l = mid + 1; } } else { if (nums[mid] \u0026lt;= target \u0026amp;\u0026amp; target \u0026lt;= nums[n-1]) { l = mid + 1; } else { r = mid - 1; } } } return -1; } }; ","date":"2021-10-25T16:47:56+08:00","permalink":"https://hh02.github.io/p/leetcode-33.-search-in-rotated-sorted-array/","title":"LeetCode 33. Search in Rotated Sorted Array"},{"content":"2048. Next Greater Numerically Balanced Number 题目 An integer x is numerically balanced if for every digit d in the number x, there are exactly d occurrences of that digit in x.\nGiven an integer n, return the smallest numerically balanced number strictly greater than n.\nExample 1:\nInput: n = 1 Output: 22 Explanation: 22 is numerically balanced since: - The digit 2 occurs 2 times. It is also the smallest numerically balanced number strictly greater than 1. 思路 思路一：可以直接从 n 开始暴力枚举判断。\n思路二：n 是 6 位数的，所以可以先把 7 位数以内所有的结果构造出来，然后用二分查找，这种解法速度更快。\n代码 用的是思路二：\nclass Solution { public: void dfs(int i, vector\u0026lt;int\u0026gt;\u0026amp; tmp, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; p) { if (i \u0026gt; 7) { p.push_back(tmp); return; } dfs(i+1, tmp, p); tmp.push_back(i); dfs(i+1, tmp, p); tmp.pop_back(); } void calc(int* c, long long num, vector\u0026lt;long long\u0026gt;\u0026amp; nums) { if (!c[1] \u0026amp;\u0026amp; !c[2] \u0026amp;\u0026amp; !c[3] \u0026amp;\u0026amp; !c[4] \u0026amp;\u0026amp; !c[5] \u0026amp;\u0026amp; !c[6] \u0026amp;\u0026amp; !c[7]) { nums.push_back(num); return; } for (int i = 1; i \u0026lt;= 7; i++) { if (c[i]) { c[i]--; calc(c, num*10 + i, nums); c[i]++; } } } int nextBeautifulNumber(int n) { vector\u0026lt;int\u0026gt; tmp; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; p; dfs(1, tmp, p); vector\u0026lt;long long\u0026gt; nums; for (const auto\u0026amp; t: p) { int c[10]; memset(c, 0, sizeof(c)); int sum = 0; for (const auto j: t) { sum += j; c[j] = j; } if (sum \u0026lt;= 8) calc(c, 0, nums); } sort(nums.begin(), nums.end()); int l = 0, r = nums.size() - 1, ans = 0; while (l \u0026lt;= r) { int mid = (l+r) / 2; if (nums[mid] \u0026gt; n) { ans = nums[mid]; r = mid - 1; } else { l = mid + 1; } } return ans; } }; ","date":"2021-10-25T15:22:51+08:00","permalink":"https://hh02.github.io/p/leetcode-weekly-contest-264/","title":"LeetCode Weekly Contest 264"},{"content":"题目 You are given an integer array nums. In one move, you can pick an index i where 0 \u0026lt;= i \u0026lt; nums.length and increment nums[i] by 1.\nReturn the minimum number of moves to make every value in nums unique.\nExample 1:\nInput: nums = [1,2,2] Output: 1 Explanation: After 1 move, the array could be [1, 2, 3]. 思路 遍历 nums 数组，遇到有重复的数字，加到不重复为止。\n这个于哈希有点类似，当遇到重复时候向后寻找空位，但是有可能超时，可以用路径压缩（类似于并查集）进行加速。比官方题解 NlogN 解法要快一点。\n代码 class Solution { public: int find(int x, int* d) { if (d[x + d[x]] != 0) { d[x] += find(x + d[x], d); } return d[x]; } int minIncrementForUnique(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = *max_element(nums.begin(), nums.end()); int d[n * 2 + 10]; memset(d, 0, sizeof(d)); int ans = 0; for (const auto\u0026amp; t: nums) { int p = find(t, d); ans += p; d[t + p] = 1; } return ans; } }; ","date":"2021-10-25T15:13:52+08:00","permalink":"https://hh02.github.io/p/leetcode-945.-minimum-increment-to-make-array-unique/","title":"LeetCode 945. Minimum Increment to Make Array Unique"},{"content":"题目 Given the head of a singly linked list, reverse the list, and return the reversed list.\nExample 1:\n 20211023233452 \nInput: head = [1,2,3,4,5] Output: [5,4,3,2,1] 思路 有迭代和递归两种写法。\n代码 迭代 class Solution { public: ListNode* reverseList(ListNode* head) { if (head == nullptr) return nullptr; ListNode* p1 = nullptr; ListNode* p2 = head; ListNode* p3; while(p2) { p3 = p2-\u0026gt;next; p2-\u0026gt;next = p1; p1 = p2; p2 = p3; } return p1; } }; 递归 class Solution { public: ListNode* reverseList(ListNode* head) { if (!head || !head-\u0026gt;next) { return head; } ListNode* newHead = reverseList(head-\u0026gt;next); head-\u0026gt;next-\u0026gt;next = head; head-\u0026gt;next = nullptr; return newHead; } }; ","date":"2021-10-23T23:21:59+08:00","permalink":"https://hh02.github.io/p/leetcode-206.-reverse-linked-list/","title":"LeetCode 206. Reverse Linked List"},{"content":"题目 Given an n x n matrix where each of the rows and columns are sorted in ascending order, return the kth smallest element in the matrix.\nNote that it is the kth smallest element in the sorted order, not the kth distinct element.\n思路 二分查找。查找比 mid 小的有多少个。因为矩阵是有序的，所以可以很快计算出来比 mid 小的有多少。所以速度很快。\n代码 class Solution { public: bool check(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix, int mid, int k, int n) { int i = n - 1; int j = 0; int num = 0; while (i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt; n) { if (matrix[i][j] \u0026lt;= mid) { num += i + 1; j++; } else { i--; } } return num \u0026gt;= k; } int kthSmallest(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix, int k) { int n = matrix.size(); int l = matrix[0][0]; int r = matrix[n-1][n-1]; while (l \u0026lt; r) { int mid = l + (r - l) / 2; if (check(matrix, mid, k, n)) { r = mid; } else { l = mid + 1; } } return l; } }; ","date":"2021-10-22T23:03:34+08:00","permalink":"https://hh02.github.io/p/leetcode-378.-kth-smallest-element-in-a-sorted-matrix/","title":"LeetCode 378. Kth Smallest Element in a Sorted Matrix"},{"content":"38.外观数列 class Solution { public: string countAndSay(int n) { if (n == 1) { return \u0026#34;1\u0026#34;; } string t1 = \u0026#34;1\u0026#34;; string t2 = \u0026#34;\u0026#34;; for (int i = 2; i \u0026lt;= n; i++) { int j = 0; int len = t1.size(); while (j \u0026lt; len) { int cnt = 1; while (j + 1 \u0026lt; len \u0026amp;\u0026amp; t1[j] == t1[j+1]) { j++; cnt++; } t2 += to_string(cnt); t2 += t1[j]; j++; } swap(t1, t2); t2 = \u0026#34;\u0026#34;; } return t1; } }; 39.组合总和 class Solution { public: void dfs(int i, vector\u0026lt;int\u0026gt;\u0026amp; tmp, int target, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;ans, const vector\u0026lt;int\u0026gt;\u0026amp; candidates) { if (target == 0) { ans.push_back(tmp); return; } if (i \u0026gt;= candidates.size() || target \u0026lt; candidates[i]) { return; } tmp.push_back(candidates[i]); dfs(i, tmp, target-candidates[i], ans, candidates); tmp.pop_back(); dfs(i + 1, tmp, target, ans, candidates); } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; combinationSum(vector\u0026lt;int\u0026gt;\u0026amp; candidates, int target) { sort(candidates.begin(), candidates.end()); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; vector\u0026lt;int\u0026gt; tmp; dfs(0, tmp, target, ans, candidates); return ans; } }; 40.组合总和-ii class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; combinationSum2(vector\u0026lt;int\u0026gt;\u0026amp; candidates, int target) { int cnt[51]; memset(cnt, 0, sizeof(cnt)); for (const auto\u0026amp; t: candidates) { cnt[t]++; } sort(candidates.begin(), candidates.end()); int m = unique(candidates.begin(), candidates.end()) - candidates.begin(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; vector\u0026lt;int\u0026gt; tmp; dfs(0, tmp, target, ans, candidates, m, cnt); return ans; } void dfs(int i, vector\u0026lt;int\u0026gt;\u0026amp; tmp, int target, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;ans, const vector\u0026lt;int\u0026gt;\u0026amp; candidates, int m, int* cnt) { if (target == 0) { ans.push_back(tmp); return; } if (i \u0026gt;= m || target \u0026lt; candidates[i]) { return; } if (cnt[candidates[i]]) { tmp.push_back(candidates[i]); cnt[candidates[i]]--; dfs(i, tmp, target-candidates[i], ans, candidates, m, cnt); tmp.pop_back(); cnt[candidates[i]]++; } dfs(i + 1, tmp, target, ans, candidates, m, cnt); } }; ","date":"2021-10-11T19:30:44+08:00","permalink":"https://hh02.github.io/p/leetcode%E5%88%B7%E9%A2%9820211011/","title":"LeetCode刷题20211011"},{"content":"29 两数相除 要求不使用乘法、除法和 mod 运算符。\nclass Solution { public: int divide(int dividend, int divisor) { if (dividend == 0) return 0; if (divisor == 1) return dividend; if (divisor == -1) { if (dividend \u0026gt; INT_MIN) return -dividend; return INT_MAX; } long long a = dividend; long long b = divisor; int sign = 1; if ((a \u0026gt; 0 \u0026amp;\u0026amp; b \u0026lt; 0) || (a \u0026lt; 0 \u0026amp;\u0026amp; b \u0026gt; 0)) { sign = -1; } a = a \u0026gt; 0 ? a : -a; b = b \u0026gt; 0 ? b : -b; long long ret = calc(a, b); if (sign \u0026gt; 0) return ret \u0026gt; INT_MAX? INT_MAX: ret; return -ret; } int calc(long long a, long long b) { if (a \u0026lt; b) return 0; long long cnt = 1; long long tb = b; while (tb \u0026lt;= a) { tb \u0026lt;\u0026lt;= 1; cnt \u0026lt;\u0026lt;= 1; } tb \u0026gt;\u0026gt;= 1; cnt \u0026gt;\u0026gt;= 1; return cnt + calc(a - tb, b); } }; 31. 下一个排列 从右往左找第一个 a[i] \u0026lt; a[i+1] 的，然后翻转 [i+1, n);\nclass Solution { public: void nextPermutation(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int i = nums.size() - 2; while (i \u0026gt;= 0 \u0026amp;\u0026amp; nums[i] \u0026gt;= nums[i + 1]) { i--; } if (i \u0026gt;= 0) { int j = nums.size() - 1; while (j \u0026gt;= 0 \u0026amp;\u0026amp; nums[i] \u0026gt;= nums[j]) { j--; } swap(nums[i], nums[j]); } reverse(nums.begin() + i + 1, nums.end()); } }; 33.搜索旋转排序数组 这题居然可以用二分！！!\n只要对二分修改一下就行：\n因为整个数组只有一个不单调点，要么在左区间[l, mid]，要么在右区间[mid+1, r]，所以有且只有一个区间是单调的，也就是说区间左端点的值小于右端点的值。对于这个单调的区间，可以判断 target 是否在这个区间，这样每次就可以排除一半的区间。\nclass Solution { public: int search(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int n = nums.size(); if (!n) return -1; if (n == 1) { return nums[0] == target ? 0 : -1; } int l = 0, r = n - 1; while (l \u0026lt;= r) { int mid = (l + r) / 2; if (nums[mid] == target) return mid; if (nums[0] \u0026lt;= nums[mid]) { if (nums[0] \u0026lt;= target \u0026amp;\u0026amp; target \u0026lt; nums[mid]) { r = mid -1; } else { l = mid + 1; } } else { if (nums[mid] \u0026lt; target \u0026amp;\u0026amp; target \u0026lt;= nums[n-1]) { l = mid + 1; } else { r = mid - 1; } } } return -1; } }; 34.在排序数组中查找元素的第一个和最后一个位置 这题可以用 lower_bound 和 upper_bound 做，若存在 target，lower_bound 返回的是第一个 target 的位置， upper_bound 返回的是最后一个 target 的位置的后一个位置，正好是一个左闭右开的区间：[l, r)。\nclass Solution { public: vector\u0026lt;int\u0026gt; searchRange(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int n = nums.size(); if (!n) { return {-1, -1}; } int pos = lower_bound(nums.begin(), nums.end(), target) - nums.begin(); if (pos \u0026gt;= n || pos \u0026lt; 0 || nums[pos] != target) { return {-1, -1}; } int pos2 = upper_bound(nums.begin(), nums.end(), target) - nums.begin() - 1; return {pos, pos2}; } }; 36.有效的数独 九宫格的位置可以计算出来，不用这么麻烦的判断。\nclass Solution { public: int calc(int i, int j) { if (i \u0026lt; 3) { if (j \u0026lt; 3) return 0; if (j \u0026lt; 6) return 1; if (j \u0026lt; 9) return 2; } if (i \u0026lt; 6) { if (j \u0026lt; 3) return 3; if (j \u0026lt; 6) return 4; if (j \u0026lt; 9) return 5; } if (j \u0026lt; 3) return 6; if (j \u0026lt; 6) return 7; return 8; } bool isValidSudoku(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board) { bool area[10][10], row[10][10], col[10][10]; memset(area, 0, sizeof(area)); memset(row, 0, sizeof(row)); memset(col, 0, sizeof(col)); for (int i = 0; i \u0026lt; 9; i++) { for (int j = 0; j \u0026lt; 9; j++) { if (board[i][j] \u0026lt; \u0026#39;0\u0026#39; || board[i][j] \u0026gt; \u0026#39;9\u0026#39;) continue; int tmp = board[i][j] - \u0026#39;0\u0026#39;; int a = calc(i, j); if (area[a][tmp]) return false; if (row[i][tmp]) return false; if (col[j][tmp]) return false; area[a][tmp] = row[i][tmp] = col[j][tmp] = true; } } } }; ","date":"2021-10-10T22:54:10+08:00","permalink":"https://hh02.github.io/p/leetcode%E5%88%B7%E9%A2%982021-10-10/","title":"LeetCode刷题2021 10 10"},{"content":"   题目 题目难度 提交次数     #14 最长公共前缀 简单 1 次   #13 罗马数字转整数 简单 3 次   #12 整数转罗马数字 中等 2 次   #11 盛最多水的容器 中等 1 次   #9 回文数 简单 1 次   #8 字符串转换整数 (atoi) 中等 7 次   #7 整数反转 简单 5 次   #6 Z 字形变换 中等 3 次    6. Z 字形变换 方法一：迭代，将每个字符放到对应行，然后输出。\n方法二：找每一行的字符对应的索引\n7. 整数反转 ret * 10 + digit \u0026lt;= INT_MAX\n$$ ret \u0026lt;= \\lfloor \\frac{intmax-digit}{10} \\rfloor $$\nret * 10 + dight \u0026lt;= INT_MAX / 10 * 10 + INT_MAX % 10\n(ret - INT_MAX / 10) * 10 \u0026lt;= 7 - digit\n若 ret \u0026gt; INT_MAX / 10, 不等式不成立\n若 ret == INT_MAX / 10，在 digit \u0026lt;= 7 时成立，因为 int 首位最大是2, 所以成立\n若 ret \u0026lt; INT_MAX / 10, 不等式成立\n所以比较 ret 和 INT_MAX / 10 可防止溢出。\n8. 字符串转换整数 (atoi) 自动机，但我是直接模拟的。\n9. 回文数 class Solution { public: bool isPalindrome(int x) { if (x \u0026lt; 0 || (x % 10 == 0 \u0026amp;\u0026amp; x != 0)) { return false; } int revertedNumber = 0; while (x \u0026gt; revertedNumber) { // 这一行的判断方法很好！  revertedNumber = revertedNumber * 10 + x % 10; x /= 10; } return x == revertedNumber || x == revertedNumber / 10; } }; 11. 盛最多水的容器 双指针法，减小了搜索空间。每次排除不可能是最优解的。\nhttps://leetcode-cn.com/problems/container-with-most-water/solution/on-shuang-zhi-zhen-jie-fa-li-jie-zheng-que-xing-tu/\nclass Solution { public: int maxArea(vector\u0026lt;int\u0026gt;\u0026amp; height) { int l = 0, r = height.size() - 1; int ans = 0; while (l \u0026lt; r) { int area = min(height[l], height[r]) * (r - l); ans = max(ans, area); if (height[l] \u0026lt;= height[r]) l++; else r--; } return ans; } }; ","date":"2021-10-08T23:21:36+08:00","permalink":"https://hh02.github.io/p/leetcode%E5%88%B7%E9%A2%982021-10-8/","title":"LeetCode刷题2021 10 8"}]