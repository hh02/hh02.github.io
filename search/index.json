[{"content":"题目 Given an n x n matrix where each of the rows and columns are sorted in ascending order, return the kth smallest element in the matrix.\nNote that it is the kth smallest element in the sorted order, not the kth distinct element.\n思路 二分查找。查找比 mid 小的有多少个。因为矩阵是有序的，所以可以很快计算出来比 mid 小的有多少。所以速度很快。\n代码 class Solution { public: bool check(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix, int mid, int k, int n) { int i = n - 1; int j = 0; int num = 0; while (i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt; n) { if (matrix[i][j] \u0026lt;= mid) { num += i + 1; j++; } else { i--; } } return num \u0026gt;= k; } int kthSmallest(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix, int k) { int n = matrix.size(); int l = matrix[0][0]; int r = matrix[n-1][n-1]; while (l \u0026lt; r) { int mid = l + (r - l) / 2; if (check(matrix, mid, k, n)) { r = mid; } else { l = mid + 1; } } return l; } }; ","date":"2021-10-22T23:03:34+08:00","permalink":"https://hh02.github.io/p/leetcode-378.-kth-smallest-element-in-a-sorted-matrix/","title":"LeetCode 378. Kth Smallest Element in a Sorted Matrix"},{"content":"38.外观数列 class Solution { public: string countAndSay(int n) { if (n == 1) { return \u0026#34;1\u0026#34;; } string t1 = \u0026#34;1\u0026#34;; string t2 = \u0026#34;\u0026#34;; for (int i = 2; i \u0026lt;= n; i++) { int j = 0; int len = t1.size(); while (j \u0026lt; len) { int cnt = 1; while (j + 1 \u0026lt; len \u0026amp;\u0026amp; t1[j] == t1[j+1]) { j++; cnt++; } t2 += to_string(cnt); t2 += t1[j]; j++; } swap(t1, t2); t2 = \u0026#34;\u0026#34;; } return t1; } }; 39.组合总和 class Solution { public: void dfs(int i, vector\u0026lt;int\u0026gt;\u0026amp; tmp, int target, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;ans, const vector\u0026lt;int\u0026gt;\u0026amp; candidates) { if (target == 0) { ans.push_back(tmp); return; } if (i \u0026gt;= candidates.size() || target \u0026lt; candidates[i]) { return; } tmp.push_back(candidates[i]); dfs(i, tmp, target-candidates[i], ans, candidates); tmp.pop_back(); dfs(i + 1, tmp, target, ans, candidates); } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; combinationSum(vector\u0026lt;int\u0026gt;\u0026amp; candidates, int target) { sort(candidates.begin(), candidates.end()); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; vector\u0026lt;int\u0026gt; tmp; dfs(0, tmp, target, ans, candidates); return ans; } }; 40.组合总和-ii class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; combinationSum2(vector\u0026lt;int\u0026gt;\u0026amp; candidates, int target) { int cnt[51]; memset(cnt, 0, sizeof(cnt)); for (const auto\u0026amp; t: candidates) { cnt[t]++; } sort(candidates.begin(), candidates.end()); int m = unique(candidates.begin(), candidates.end()) - candidates.begin(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; vector\u0026lt;int\u0026gt; tmp; dfs(0, tmp, target, ans, candidates, m, cnt); return ans; } void dfs(int i, vector\u0026lt;int\u0026gt;\u0026amp; tmp, int target, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;ans, const vector\u0026lt;int\u0026gt;\u0026amp; candidates, int m, int* cnt) { if (target == 0) { ans.push_back(tmp); return; } if (i \u0026gt;= m || target \u0026lt; candidates[i]) { return; } if (cnt[candidates[i]]) { tmp.push_back(candidates[i]); cnt[candidates[i]]--; dfs(i, tmp, target-candidates[i], ans, candidates, m, cnt); tmp.pop_back(); cnt[candidates[i]]++; } dfs(i + 1, tmp, target, ans, candidates, m, cnt); } }; ","date":"2021-10-11T19:30:44+08:00","permalink":"https://hh02.github.io/p/leetcode%E5%88%B7%E9%A2%9820211011/","title":"LeetCode刷题20211011"},{"content":"29 两数相除 要求不使用乘法、除法和 mod 运算符。\nclass Solution { public: int divide(int dividend, int divisor) { if (dividend == 0) return 0; if (divisor == 1) return dividend; if (divisor == -1) { if (dividend \u0026gt; INT_MIN) return -dividend; return INT_MAX; } long long a = dividend; long long b = divisor; int sign = 1; if ((a \u0026gt; 0 \u0026amp;\u0026amp; b \u0026lt; 0) || (a \u0026lt; 0 \u0026amp;\u0026amp; b \u0026gt; 0)) { sign = -1; } a = a \u0026gt; 0 ? a : -a; b = b \u0026gt; 0 ? b : -b; long long ret = calc(a, b); if (sign \u0026gt; 0) return ret \u0026gt; INT_MAX? INT_MAX: ret; return -ret; } int calc(long long a, long long b) { if (a \u0026lt; b) return 0; long long cnt = 1; long long tb = b; while (tb \u0026lt;= a) { tb \u0026lt;\u0026lt;= 1; cnt \u0026lt;\u0026lt;= 1; } tb \u0026gt;\u0026gt;= 1; cnt \u0026gt;\u0026gt;= 1; return cnt + calc(a - tb, b); } }; 31. 下一个排列 从右往左找第一个 a[i] \u0026lt; a[i+1] 的，然后翻转 [i+1, n);\nclass Solution { public: void nextPermutation(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int i = nums.size() - 2; while (i \u0026gt;= 0 \u0026amp;\u0026amp; nums[i] \u0026gt;= nums[i + 1]) { i--; } if (i \u0026gt;= 0) { int j = nums.size() - 1; while (j \u0026gt;= 0 \u0026amp;\u0026amp; nums[i] \u0026gt;= nums[j]) { j--; } swap(nums[i], nums[j]); } reverse(nums.begin() + i + 1, nums.end()); } }; 33.搜索旋转排序数组 这题居然可以用二分！！!\n只要对二分修改一下就行：\n因为整个数组只有一个不单调点，要么在左区间[l, mid]，要么在右区间[mid+1, r]，所以有且只有一个区间是单调的，也就是说区间左端点的值小于右端点的值。对于这个单调的区间，可以判断 target 是否在这个区间，这样每次就可以排除一半的区间。\nclass Solution { public: int search(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int n = nums.size(); if (!n) return -1; if (n == 1) { return nums[0] == target ? 0 : -1; } int l = 0, r = n - 1; while (l \u0026lt;= r) { int mid = (l + r) / 2; if (nums[mid] == target) return mid; if (nums[0] \u0026lt;= nums[mid]) { if (nums[0] \u0026lt;= target \u0026amp;\u0026amp; target \u0026lt; nums[mid]) { r = mid -1; } else { l = mid + 1; } } else { if (nums[mid] \u0026lt; target \u0026amp;\u0026amp; target \u0026lt;= nums[n-1]) { l = mid + 1; } else { r = mid - 1; } } } return -1; } }; 34.在排序数组中查找元素的第一个和最后一个位置 这题可以用 lower_bound 和 upper_bound 做，若存在 target，lower_bound 返回的是第一个 target 的位置， upper_bound 返回的是最后一个 target 的位置的后一个位置，正好是一个左闭右开的区间：[l, r)。\nclass Solution { public: vector\u0026lt;int\u0026gt; searchRange(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int n = nums.size(); if (!n) { return {-1, -1}; } int pos = lower_bound(nums.begin(), nums.end(), target) - nums.begin(); if (pos \u0026gt;= n || pos \u0026lt; 0 || nums[pos] != target) { return {-1, -1}; } int pos2 = upper_bound(nums.begin(), nums.end(), target) - nums.begin() - 1; return {pos, pos2}; } }; 36.有效的数独 九宫格的位置可以计算出来，不用这么麻烦的判断。\nclass Solution { public: int calc(int i, int j) { if (i \u0026lt; 3) { if (j \u0026lt; 3) return 0; if (j \u0026lt; 6) return 1; if (j \u0026lt; 9) return 2; } if (i \u0026lt; 6) { if (j \u0026lt; 3) return 3; if (j \u0026lt; 6) return 4; if (j \u0026lt; 9) return 5; } if (j \u0026lt; 3) return 6; if (j \u0026lt; 6) return 7; return 8; } bool isValidSudoku(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board) { bool area[10][10], row[10][10], col[10][10]; memset(area, 0, sizeof(area)); memset(row, 0, sizeof(row)); memset(col, 0, sizeof(col)); for (int i = 0; i \u0026lt; 9; i++) { for (int j = 0; j \u0026lt; 9; j++) { if (board[i][j] \u0026lt; \u0026#39;0\u0026#39; || board[i][j] \u0026gt; \u0026#39;9\u0026#39;) continue; int tmp = board[i][j] - \u0026#39;0\u0026#39;; int a = calc(i, j); if (area[a][tmp]) return false; if (row[i][tmp]) return false; if (col[j][tmp]) return false; area[a][tmp] = row[i][tmp] = col[j][tmp] = true; } } } }; ","date":"2021-10-10T22:54:10+08:00","permalink":"https://hh02.github.io/p/leetcode%E5%88%B7%E9%A2%982021-10-10/","title":"LeetCode刷题2021 10 10"},{"content":"   题目 题目难度 提交次数     #14 最长公共前缀 简单 1 次   #13 罗马数字转整数 简单 3 次   #12 整数转罗马数字 中等 2 次   #11 盛最多水的容器 中等 1 次   #9 回文数 简单 1 次   #8 字符串转换整数 (atoi) 中等 7 次   #7 整数反转 简单 5 次   #6 Z 字形变换 中等 3 次    6. Z 字形变换 方法一：迭代，将每个字符放到对应行，然后输出。\n方法二：找每一行的字符对应的索引\n7. 整数反转 ret * 10 + digit \u0026lt;= INT_MAX\n$$ ret \u0026lt;= \\lfloor \\frac{intmax-digit}{10} \\rfloor $$\nret * 10 + dight \u0026lt;= INT_MAX / 10 * 10 + INT_MAX % 10\n(ret - INT_MAX / 10) * 10 \u0026lt;= 7 - digit\n若 ret \u0026gt; INT_MAX / 10, 不等式不成立\n若 ret == INT_MAX / 10，在 digit \u0026lt;= 7 时成立，因为 int 首位最大是2, 所以成立\n若 ret \u0026lt; INT_MAX / 10, 不等式成立\n所以比较 ret 和 INT_MAX / 10 可防止溢出。\n8. 字符串转换整数 (atoi) 自动机，但我是直接模拟的。\n9. 回文数 class Solution { public: bool isPalindrome(int x) { if (x \u0026lt; 0 || (x % 10 == 0 \u0026amp;\u0026amp; x != 0)) { return false; } int revertedNumber = 0; while (x \u0026gt; revertedNumber) { // 这一行的判断方法很好！  revertedNumber = revertedNumber * 10 + x % 10; x /= 10; } return x == revertedNumber || x == revertedNumber / 10; } }; 11. 盛最多水的容器 双指针法，减小了搜索空间。每次排除不可能是最优解的。\nhttps://leetcode-cn.com/problems/container-with-most-water/solution/on-shuang-zhi-zhen-jie-fa-li-jie-zheng-que-xing-tu/\nclass Solution { public: int maxArea(vector\u0026lt;int\u0026gt;\u0026amp; height) { int l = 0, r = height.size() - 1; int ans = 0; while (l \u0026lt; r) { int area = min(height[l], height[r]) * (r - l); ans = max(ans, area); if (height[l] \u0026lt;= height[r]) l++; else r--; } return ans; } }; ","date":"2021-10-08T23:21:36+08:00","permalink":"https://hh02.github.io/p/leetcode%E5%88%B7%E9%A2%982021-10-8/","title":"LeetCode刷题2021 10 8"}]